package com.mrgq.pdfviewer

import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.pdf.PdfRenderer
import android.os.Bundle
import android.os.ParcelFileDescriptor
import android.view.KeyEvent
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.app.AlertDialog
import com.mrgq.pdfviewer.databinding.ActivityPdfViewerBinding
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import android.util.Log
import android.content.SharedPreferences
import android.util.DisplayMetrics
import android.os.Environment
import java.io.File
import com.mrgq.pdfviewer.database.entity.DisplayMode
import com.mrgq.pdfviewer.database.entity.PageOrientation
import com.mrgq.pdfviewer.database.entity.UserPreference
import com.mrgq.pdfviewer.repository.MusicRepository
import com.mrgq.pdfviewer.utils.PdfAnalyzer
import android.os.Handler
import android.os.Looper

class PdfViewerActivity : AppCompatActivity() {
    
    private lateinit var binding: ActivityPdfViewerBinding
    private var pdfRenderer: PdfRenderer? = null
    private var currentPage: PdfRenderer.Page? = null
    private var pageIndex = 0
    private var pageCount = 0
    private lateinit var pdfFilePath: String
    private lateinit var pdfFileName: String
    private var currentFileIndex = 0
    private var filePathList: List<String> = emptyList()
    private var fileNameList: List<String> = emptyList()
    
    // Navigation guide state
    private var isNavigationGuideVisible = false
    private var navigationGuideType = ""  // "end" or "start"
    
    // Two-page mode
    private var isTwoPageMode = false
    private var screenWidth = 0
    private var screenHeight = 0
    private lateinit var preferences: SharedPreferences
    
    // Collaboration
    private var collaborationMode = CollaborationMode.NONE
    private val globalCollaborationManager = GlobalCollaborationManager.getInstance()
    
    // Page caching for instant page switching
    private var pageCache: PageCache? = null
    
    // Database repository
    private lateinit var musicRepository: MusicRepository
    private var currentPdfFileId: String? = null
    
    // Current display settings
    private var currentTopClipping: Float = 0f
    private var currentBottomClipping: Float = 0f
    private var currentCenterPadding: Float = 0f  // Changed to Float for percentage (0.0 - 0.15)
    
    // Flag to force direct rendering (bypass cache) after settings change
    private var forceDirectRendering: Boolean = false
    
    // Long press handling for OK button
    private var isLongPressing = false
    private val longPressHandler = Handler(Looper.getMainLooper())
    private val longPressRunnable = Runnable {
        if (isLongPressing) {
            showPdfDisplayOptions()
        }
    }
    private val longPressDelay = 800L // 800ms for long press
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityPdfViewerBinding.inflate(layoutInflater)
        setContentView(binding.root)
        
        // Initialize preferences
        preferences = getSharedPreferences("pdf_viewer_prefs", MODE_PRIVATE)
        
        // Initialize database repository
        musicRepository = MusicRepository(this)
        
        // Get screen dimensions
        val displayMetrics = DisplayMetrics()
        windowManager.defaultDisplay.getMetrics(displayMetrics)
        screenWidth = displayMetrics.widthPixels
        screenHeight = displayMetrics.heightPixels
        
        currentFileIndex = intent.getIntExtra("current_index", 0)
        filePathList = intent.getStringArrayListExtra("file_path_list") ?: emptyList()
        fileNameList = intent.getStringArrayListExtra("file_name_list") ?: emptyList()
        
        // Check if there's a target page from collaboration
        val targetPage = intent.getIntExtra("target_page", -1)
        Log.d("PdfViewerActivity", "Target page from intent: $targetPage")
        
        // Î∞õÏùÄ ÌååÏùº Î™©Î°ù Î°úÍ∑∏
        Log.d("PdfViewerActivity", "=== RECEIVED FILE LIST ===")
        filePathList.forEachIndexed { index, path ->
            val name = if (index < fileNameList.size) fileNameList[index] else "Unknown"
            Log.d("PdfViewerActivity", "[$index] NAME: '$name' PATH: '$path'")
        }
        Log.d("PdfViewerActivity", "Current file index: $currentFileIndex")
        
        // Ïù∏Îç±Ïä§Ïóê Ìï¥ÎãπÌïòÎäî ÌååÏùºÏùÑ Î°úÎìú
        if (currentFileIndex >= 0 && currentFileIndex < filePathList.size) {
            pdfFilePath = filePathList[currentFileIndex]
            pdfFileName = fileNameList[currentFileIndex]
            Log.d("PdfViewerActivity", "SELECTED FILE: '$pdfFileName' at '$pdfFilePath'")
        } else {
            Toast.makeText(this, "ÏûòÎ™ªÎêú ÌååÏùº Ïù∏Îç±Ïä§ÏûÖÎãàÎã§", Toast.LENGTH_SHORT).show()
            finish()
            return
        }
        
        if (pdfFilePath.isEmpty()) {
            Toast.makeText(this, getString(R.string.error_loading_pdf), Toast.LENGTH_SHORT).show()
            finish()
            return
        }
        
        setupUI()
        initializeCollaboration()
        loadPdf()
    }
    
    private fun setupUI() {
        binding.pdfView.isFocusable = true
        binding.pdfView.isFocusableInTouchMode = true
        binding.pdfView.requestFocus()
        
        // Hide page info after a few seconds
        binding.pageInfo.postDelayed({
            binding.pageInfo.animate().alpha(0.3f).duration = 500
        }, 3000)
    }
    
    private fun loadPdf() {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                Log.d("PdfViewerActivity", "Loading PDF: $pdfFilePath")
                val file = File(pdfFilePath)
                
                Log.d("PdfViewerActivity", "File exists: ${file.exists()}")
                Log.d("PdfViewerActivity", "File can read: ${file.canRead()}")
                Log.d("PdfViewerActivity", "File size: ${file.length()}")
                
                if (!file.exists()) {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@PdfViewerActivity, "ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: $pdfFileName", Toast.LENGTH_SHORT).show()
                        finish()
                    }
                    return@launch
                }
                
                Log.d("PdfViewerActivity", "Initial load - creating ParcelFileDescriptor...")
                val fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)
                Log.d("PdfViewerActivity", "Initial load - ParcelFileDescriptor created successfully")
                
                Log.d("PdfViewerActivity", "Initial load - creating PdfRenderer...")
                pdfRenderer = PdfRenderer(fileDescriptor)
                Log.d("PdfViewerActivity", "Initial load - PdfRenderer created successfully")
                
                pageCount = pdfRenderer?.pageCount ?: 0
                Log.d("PdfViewerActivity", "Initial load - PDF page count: $pageCount")
                
                withContext(Dispatchers.Main) {
                    if (pageCount > 0) {
                        // Add file to server if in conductor mode
                        if (collaborationMode == CollaborationMode.CONDUCTOR) {
                            Log.d("PdfViewerActivity", "üéµ ÏßÄÌúòÏûê Î™®Îìú: ÌååÏùºÏùÑ ÏÑúÎ≤ÑÏóê Ï∂îÍ∞Ä Ï§ë...")
                            globalCollaborationManager.addFileToServer(pdfFileName, pdfFilePath)
                        }
                        
                        // Initialize page cache with proper scale calculation
                        pageCache?.destroy() // Clean up previous cache
                        
                        // Calculate proper scale based on first page
                        val firstPage = pdfRenderer!!.openPage(0)
                        val calculatedScale = calculateOptimalScale(firstPage.width, firstPage.height)
                        firstPage.close()
                        
                        pageCache = PageCache(pdfRenderer!!, screenWidth, screenHeight)
                        
                        // PageCacheÏóê ÏÑ§Ï†ï ÏΩúÎ∞± Îì±Î°ù
                        registerSettingsCallback()
                        
                        Log.d("PdfViewerActivity", "PageCache Ï¥àÍ∏∞Ìôî ÏôÑÎ£å (calculated scale: $calculatedScale)")
                        
                        // Check if we should use two-page mode, then show target page or first page
                        checkAndSetTwoPageMode {
                            // Recalculate scale based on the determined mode
                            val firstPage = pdfRenderer!!.openPage(0)
                            val finalScale = calculateOptimalScale(firstPage.width, firstPage.height, isTwoPageMode)
                            firstPage.close()
                            
                            Log.d("PdfViewerActivity", "Final scale for two-page mode $isTwoPageMode: $finalScale")
                            
                            // Clear cache and update settings to ensure clean state
                            pageCache?.clear()
                            pageCache?.updateSettings(isTwoPageMode, finalScale)
                            
                            // Re-register settings provider after cache operations and settings load
                            registerSettingsCallback()
                            
                            Log.d("PdfViewerActivity", "=== ÏµúÏ¢Ö ÏΩúÎ∞± Îì±Î°ù ÏôÑÎ£å ===")
                            Log.d("PdfViewerActivity", "ÏµúÏ¢Ö ÏÑ§Ï†ï ÏÉÅÌÉú: ÏúÑ ${currentTopClipping * 100}%, ÏïÑÎûò ${currentBottomClipping * 100}%, Ïó¨Î∞± ${currentCenterPadding}px")
                            
                            // Navigate to target page if specified, otherwise first page
                            val targetPage = intent.getIntExtra("target_page", -1)
                            val initialPageIndex = if (targetPage > 0) {
                                (targetPage - 1).coerceIn(0, pageCount - 1) // Convert 1-based to 0-based
                            } else {
                                0
                            }
                            
                            Log.d("PdfViewerActivity", "Initial page navigation: targetPage=$targetPage, initialPageIndex=$initialPageIndex")
                            showPage(initialPageIndex)
                        }
                    } else {
                        Toast.makeText(this@PdfViewerActivity, "PDF ÌååÏùºÏóê ÌéòÏù¥ÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
                        finish()
                    }
                }
            } catch (e: Exception) {
                Log.e("PdfViewerActivity", "Error loading PDF", e)
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@PdfViewerActivity, "PDF Ïó¥Í∏∞ Ïã§Ìå®: ${e.message}", Toast.LENGTH_LONG).show()
                    finish()
                }
            }
        }
    }
    
    private fun checkAndSetTwoPageMode(onComplete: () -> Unit) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                // First, ensure PDF file is in database
                ensurePdfFileInDatabase()
                
                Log.d("PdfViewerActivity", "=== checkAndSetTwoPageMode: PDF ÌååÏùº DB Îì±Î°ù ÏôÑÎ£å ===")
                Log.d("PdfViewerActivity", "currentPdfFileId: $currentPdfFileId")
                
                // Load display settings after ensuring file is in database
                loadDisplaySettingsSync()
                
                Log.d("PdfViewerActivity", "=== checkAndSetTwoPageMode: ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å ===")
                Log.d("PdfViewerActivity", "Î°úÎìúÎêú ÏÑ§Ï†ï: ÏúÑ ${currentTopClipping * 100}%, ÏïÑÎûò ${currentBottomClipping * 100}%, Ïó¨Î∞± ${currentCenterPadding}px")
                
                // Force cache invalidation to apply loaded settings
                withContext(Dispatchers.Main) {
                    pageCache?.clear()
                    Log.d("PdfViewerActivity", "=== ÏÑ§Ï†ï Î°úÎìú ÌõÑ Ï∫êÏãú ÌÅ¥Î¶¨Ïñ¥ ÏôÑÎ£å ===")
                }
                
                // Check if this file already has a saved setting
                currentPdfFileId?.let { fileId ->
                    val userPreference = musicRepository.getUserPreference(fileId)
                    
                    if (userPreference != null) {
                        // File-specific setting exists
                        withContext(Dispatchers.Main) {
                            isTwoPageMode = when (userPreference.displayMode) {
                                DisplayMode.DOUBLE -> true
                                DisplayMode.SINGLE -> false
                                DisplayMode.AUTO -> {
                                    // AUTO mode: determine based on orientation
                                    val pdfFile = musicRepository.getPdfFileById(fileId)
                                    pdfFile?.let { file ->
                                        screenWidth > screenHeight && file.orientation == PageOrientation.PORTRAIT
                                    } ?: false
                                }
                            }
                            Log.d("PdfViewerActivity", "Using saved display mode: ${userPreference.displayMode} for $pdfFileName")
                            onComplete()
                        }
                        return@launch
                    }
                }
                
                // Get first page to check aspect ratio
                val firstPage = pdfRenderer?.openPage(0)
                firstPage?.let { page ->
                    val pdfWidth = page.width
                    val pdfHeight = page.height
                    page.close()
                    
                    val screenAspectRatio = screenWidth.toFloat() / screenHeight.toFloat()
                    val pdfAspectRatio = pdfWidth.toFloat() / pdfHeight.toFloat()
                    
                    Log.d("PdfViewerActivity", "Screen aspect ratio: $screenAspectRatio")
                    Log.d("PdfViewerActivity", "PDF aspect ratio: $pdfAspectRatio")
                    
                    withContext(Dispatchers.Main) {
                        // Check if aspect ratios are compatible (difference < 0.3)
                        val aspectRatioDiff = kotlin.math.abs(screenAspectRatio - pdfAspectRatio)
                        
                        if (aspectRatioDiff < 0.3f) {
                            // Aspect ratios are similar, use single page mode - NO SAVING
                            isTwoPageMode = false
                            Log.d("PdfViewerActivity", "Aspect ratios match (diff: $aspectRatioDiff), using single page mode (no saving)")
                            onComplete()
                        } else if (screenAspectRatio > 1.0f && pdfAspectRatio < 1.0f) {
                            // Screen is landscape and PDF is portrait - ask user
                            Log.d("PdfViewerActivity", "Landscape screen + Portrait PDF, asking user")
                            showTwoPageModeDialog(onComplete)
                        } else {
                            // Other cases (portrait screen, landscape PDF, etc.) - use single page - NO SAVING
                            isTwoPageMode = false
                            Log.d("PdfViewerActivity", "Other aspect ratio case, using single page mode (no saving)")
                            onComplete()
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e("PdfViewerActivity", "Error checking aspect ratio", e)
                withContext(Dispatchers.Main) {
                    isTwoPageMode = false
                    onComplete()
                }
            }
        }
    }
    
    private suspend fun ensurePdfFileInDatabase() {
        try {
            val file = File(pdfFilePath)
            if (!file.exists()) return
            
            // Check if file already exists in database
            val existingPdfFile = musicRepository.getPdfFileByPath(pdfFilePath)
            
            if (existingPdfFile != null) {
                currentPdfFileId = existingPdfFile.id
                Log.d("PdfViewerActivity", "Found existing PDF file in database: ${existingPdfFile.id}")
                return
            }
            
            // Analyze and insert new PDF file
            val pdfFile = PdfAnalyzer.analyzePdfFile(file)
            if (pdfFile != null) {
                musicRepository.insertPdfFile(pdfFile)
                currentPdfFileId = pdfFile.id
                Log.d("PdfViewerActivity", "Inserted new PDF file into database: ${pdfFile.id}")
            } else {
                Log.e("PdfViewerActivity", "Failed to analyze PDF file: $pdfFilePath")
            }
        } catch (e: Exception) {
            Log.e("PdfViewerActivity", "Error ensuring PDF file in database", e)
        }
    }
    
    private fun getFileKey(filePath: String): String {
        // Create a unique key for the file based on path and size
        return try {
            val file = File(filePath)
            "${file.name}_${file.length()}"
        } catch (e: Exception) {
            filePath.hashCode().toString()
        }
    }
    
    private fun saveDisplayModePreference(displayMode: DisplayMode) {
        currentPdfFileId?.let { fileId ->
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    musicRepository.setDisplayModeForFile(fileId, displayMode)
                    Log.d("PdfViewerActivity", "Saved display mode preference: $displayMode for file: $fileId")
                } catch (e: Exception) {
                    Log.e("PdfViewerActivity", "Error saving display mode preference", e)
                }
            }
        }
    }
    
    private fun saveLastPageNumber(pageNumber: Int) {
        currentPdfFileId?.let { fileId ->
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    musicRepository.setLastPageForFile(fileId, pageNumber)
                    // Don't log every page change to avoid spam
                } catch (e: Exception) {
                    Log.e("PdfViewerActivity", "Error saving last page number", e)
                }
            }
        }
    }
    
    private fun showTwoPageModeDialog(onComplete: () -> Unit) {
        // Create custom dialog with checkbox
        val dialogView = layoutInflater.inflate(android.R.layout.select_dialog_multichoice, null)
        
        // Create a simple custom layout
        val linearLayout = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            setPadding(60, 40, 60, 40)
        }
        
        // Message text
        val messageText = android.widget.TextView(this).apply {
            text = "ÏÑ∏Î°ú PDFÎ•º Í∞ÄÎ°ú ÌôîÎ©¥ÏóêÏÑú Î≥¥Í≥† ÏûàÏäµÎãàÎã§.\n'$pdfFileName' ÌååÏùºÏùÑ Ïñ¥ÎñªÍ≤å ÌëúÏãúÌïòÏãúÍ≤†ÏäµÎãàÍπå?"
            textSize = 16f
            setPadding(0, 0, 0, 30)
        }
        
        // Checkbox for "remember choice"
        val rememberCheckbox = android.widget.CheckBox(this).apply {
            text = "Ïù¥ ÏÑ†ÌÉùÏùÑ Í∏∞ÏñµÌïòÍ∏∞"
            isChecked = true
            textSize = 14f
            setPadding(0, 20, 0, 0)
        }
        
        linearLayout.addView(messageText)
        linearLayout.addView(rememberCheckbox)
        
        AlertDialog.Builder(this)
            .setTitle("ÌéòÏù¥ÏßÄ ÌëúÏãú Î™®Îìú")
            .setView(linearLayout)
            .setPositiveButton("Îëê ÌéòÏù¥ÏßÄÎ°ú Î≥¥Í∏∞") { _, _ ->
                isTwoPageMode = true
                if (rememberCheckbox.isChecked) {
                    saveDisplayModePreference(DisplayMode.DOUBLE)
                    Log.d("PdfViewerActivity", "User selected two page mode (saved) for $pdfFileName")
                } else {
                    Log.d("PdfViewerActivity", "User selected two page mode (temp) for $pdfFileName")
                }
                onComplete()
            }
            .setNegativeButton("Ìïú ÌéòÏù¥ÏßÄÏî© Î≥¥Í∏∞") { _, _ ->
                isTwoPageMode = false
                if (rememberCheckbox.isChecked) {
                    saveDisplayModePreference(DisplayMode.SINGLE)
                    Log.d("PdfViewerActivity", "User selected single page mode (saved) for $pdfFileName")
                } else {
                    Log.d("PdfViewerActivity", "User selected single page mode (temp) for $pdfFileName")
                }
                onComplete()
            }
            .setCancelable(false)
            .show()
    }
    
    private fun showPage(index: Int) {
        if (index < 0 || index >= pageCount) return
        
        Log.d("PdfViewerActivity", "showPage called: index=$index, isTwoPageMode=$isTwoPageMode, pageCount=$pageCount")
        
        // Check cache first for instant display
        val cachedBitmap = if (isTwoPageMode) {
            if (index + 1 < pageCount) {
                // Two page mode - check if both pages are cached with correct scale
                val page1 = pageCache?.getPageImmediate(index)
                val page2 = pageCache?.getPageImmediate(index + 1)
                if (page1 != null && page2 != null) {
                    Log.d("PdfViewerActivity", "‚ö° ÌéòÏù¥ÏßÄ $index, ${index + 1} Ï∫êÏãúÏóêÏÑú Ï¶âÏãú ÌëúÏãú (Îëê ÌéòÏù¥ÏßÄ Î™®Îìú)")
                    combineTwoPages(page1, page2)
                } else {
                    null
                }
            } else {
                // Last page is odd - show on left side with empty right
                val page1 = pageCache?.getPageImmediate(index)
                if (page1 != null) {
                    Log.d("PdfViewerActivity", "‚ö° ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄ $index Ï∫êÏãúÏóêÏÑú ÏôºÏ™ΩÏóê ÌëúÏãú (Îëê ÌéòÏù¥ÏßÄ Î™®Îìú)")
                    combinePageWithEmpty(page1)
                } else {
                    null
                }
            }
        } else {
            pageCache?.getPageImmediate(index)
        }
        
        if (cachedBitmap != null) {
            // Cache hit - instant display!
            if (!isTwoPageMode) {
                Log.d("PdfViewerActivity", "‚ö° ÌéòÏù¥ÏßÄ $index Ï∫êÏãúÏóêÏÑú Ï¶âÏãú ÌëúÏãú")
            }
            binding.pdfView.setImageBitmap(cachedBitmap)
            setImageViewMatrix(cachedBitmap)
            pageIndex = index
            updatePageInfo()
            binding.loadingProgress.visibility = View.GONE
            
            // Save last page number to database
            saveLastPageNumber(index + 1)
            
            // Show page info briefly
            binding.pageInfo.animate().alpha(1f).duration = 200
            binding.pageInfo.postDelayed({
                binding.pageInfo.animate().alpha(0.3f).duration = 500
            }, 2000)
            
            // Start prerendering around this page
            pageCache?.prerenderAround(index)
            
            // Broadcast page change if in conductor mode
            if (collaborationMode == CollaborationMode.CONDUCTOR) {
                val actualPageNumber = if (isTwoPageMode) index + 1 else index + 1
                Log.d("PdfViewerActivity", "üéµ ÏßÄÌúòÏûê Î™®Îìú: ÌéòÏù¥ÏßÄ $actualPageNumber Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï§ë...")
                globalCollaborationManager.broadcastPageChange(actualPageNumber, pdfFileName)
            }
            
            return
        }
        
        // Cache miss - fallback to traditional rendering with loading indicator
        Log.d("PdfViewerActivity", "‚è≥ ÌéòÏù¥ÏßÄ $index Ï∫êÏãú ÎØ∏Ïä§ - Í∏∞Ï°¥ Î∞©ÏãùÏúºÎ°ú Î†åÎçîÎßÅ")
        binding.loadingProgress.visibility = View.VISIBLE
        
        CoroutineScope(Dispatchers.IO).launch {
            try {
                try {
                    currentPage?.close()
                } catch (e: Exception) {
                    Log.w("PdfViewerActivity", "Current page already closed or error closing in showPage: ${e.message}")
                }
                
                val bitmap = if (isTwoPageMode) {
                    if (index + 1 < pageCount) {
                        Log.d("PdfViewerActivity", "=== Îëê ÌéòÏù¥ÏßÄ Î™®Îìú Î†åÎçîÎßÅ: $index and ${index + 1} ===")
                        Log.d("PdfViewerActivity", "forceDirectRendering: $forceDirectRendering")
                        // For two-page mode, always use direct rendering to preserve aspect ratio
                        if (forceDirectRendering) {
                            forceDirectRendering = false // ÌîåÎûòÍ∑∏ Î¶¨ÏÖã
                        }
                        renderTwoPages(index)
                    } else {
                        Log.d("PdfViewerActivity", "=== ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄ ÏôºÏ™Ω ÌëúÏãú Î†åÎçîÎßÅ: $index ===")
                        Log.d("PdfViewerActivity", "forceDirectRendering: $forceDirectRendering")
                        if (forceDirectRendering) {
                            forceDirectRendering = false // ÌîåÎûòÍ∑∏ Î¶¨ÏÖã
                        }
                        renderSinglePageOnLeft(index)
                    }
                } else {
                    Log.d("PdfViewerActivity", "=== Îã®Ïùº ÌéòÏù¥ÏßÄ Î™®Îìú Î†åÎçîÎßÅ: $index ===")
                    Log.d("PdfViewerActivity", "forceDirectRendering: $forceDirectRendering")
                    
                    if (forceDirectRendering) {
                        Log.d("PdfViewerActivity", "ÏÑ§Ï†ï Î≥ÄÍ≤ΩÏúºÎ°ú Ïù∏Ìïú Í∞ïÏ†ú ÏßÅÏ†ë Î†åÎçîÎßÅ - Ï∫êÏãú ÏôÑÏ†Ñ Ïö∞Ìöå")
                        forceDirectRendering = false // ÌîåÎûòÍ∑∏ Î¶¨ÏÖã
                        renderSinglePage(index)
                    } else {
                        Log.d("PdfViewerActivity", "ÏùºÎ∞ò Î†åÎçîÎßÅ - PageCache ÏûêÎèô ÏÑ§Ï†ï Í¥ÄÎ¶¨ ÏÇ¨Ïö©")
                        // PageCache will automatically handle settings changes and cache invalidation
                        pageCache?.getPageImmediate(index) ?: renderSinglePage(index)
                    }
                }
                
                withContext(Dispatchers.Main) {
                    binding.pdfView.setImageBitmap(bitmap)
                    setImageViewMatrix(bitmap)
                    pageIndex = index
                    updatePageInfo()
                    binding.loadingProgress.visibility = View.GONE
                    
                    // Save last page number to database
                    saveLastPageNumber(index + 1)
                    
                    // Show page info briefly
                    binding.pageInfo.animate().alpha(1f).duration = 200
                    binding.pageInfo.postDelayed({
                        binding.pageInfo.animate().alpha(0.3f).duration = 500
                    }, 2000)
                    
                    // Start prerendering around this page
                    pageCache?.prerenderAround(index)
                    
                    // Broadcast page change if in conductor mode
                    if (collaborationMode == CollaborationMode.CONDUCTOR) {
                        val actualPageNumber = if (isTwoPageMode) index + 1 else index + 1
                        Log.d("PdfViewerActivity", "üéµ ÏßÄÌúòÏûê Î™®Îìú: ÌéòÏù¥ÏßÄ $actualPageNumber Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ Ï§ë...")
                        globalCollaborationManager.broadcastPageChange(actualPageNumber, pdfFileName)
                    }
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    binding.loadingProgress.visibility = View.GONE
                    Toast.makeText(this@PdfViewerActivity, getString(R.string.error_loading_pdf), Toast.LENGTH_SHORT).show()
                }
            }
        }
    }
    
    private fun combineTwoPages(leftBitmap: Bitmap, rightBitmap: Bitmap): Bitmap {
        Log.d("PdfViewerActivity", "=== COMBINE TWO PAGES DEBUG ===")
        Log.d("PdfViewerActivity", "Left bitmap: ${leftBitmap.width}x${leftBitmap.height}, aspect ratio: ${leftBitmap.width.toFloat() / leftBitmap.height.toFloat()}")
        Log.d("PdfViewerActivity", "Right bitmap: ${rightBitmap.width}x${rightBitmap.height}, aspect ratio: ${rightBitmap.width.toFloat() / rightBitmap.height.toFloat()}")
        // Calculate center padding in pixels (percentage of one page width)
        val paddingPixels = (leftBitmap.width * currentCenterPadding).toInt()
        Log.d("PdfViewerActivity", "Center padding: ${(currentCenterPadding * 100).toInt()}% (${paddingPixels}px)")
        
        // Create combined bitmap with center padding
        val combinedWidth = leftBitmap.width + rightBitmap.width + paddingPixels
        val combinedHeight = maxOf(leftBitmap.height, rightBitmap.height)
        
        Log.d("PdfViewerActivity", "Combined will be: ${combinedWidth}x${combinedHeight}, aspect ratio: ${combinedWidth.toFloat() / combinedHeight.toFloat()}")
        Log.d("PdfViewerActivity", "===============================")
        
        val combinedBitmap = Bitmap.createBitmap(
            combinedWidth,
            combinedHeight,
            Bitmap.Config.ARGB_8888
        )
        
        val combinedCanvas = Canvas(combinedBitmap)
        combinedCanvas.drawColor(android.graphics.Color.WHITE)
        
        // Draw left page
        combinedCanvas.drawBitmap(leftBitmap, 0f, 0f, null)
        
        // Draw right page with center padding offset
        val rightPageX = leftBitmap.width.toFloat() + paddingPixels
        combinedCanvas.drawBitmap(rightBitmap, rightPageX, 0f, null)
        
        Log.d("PdfViewerActivity", "Combined two cached pages successfully with ${(currentCenterPadding * 100).toInt()}% center padding")
        
        return combinedBitmap
    }
    
    private fun combinePageWithEmpty(leftBitmap: Bitmap): Bitmap {
        Log.d("PdfViewerActivity", "=== COMBINE PAGE WITH EMPTY DEBUG ===")
        Log.d("PdfViewerActivity", "Left bitmap: ${leftBitmap.width}x${leftBitmap.height}")
        // Calculate center padding in pixels (percentage of one page width)
        val paddingPixels = (leftBitmap.width * currentCenterPadding).toInt()
        Log.d("PdfViewerActivity", "Center padding: ${(currentCenterPadding * 100).toInt()}% (${paddingPixels}px)")
        
        // Create combined bitmap with empty right page
        val rightPageWidth = leftBitmap.width  // Same size as left page
        val combinedWidth = leftBitmap.width + rightPageWidth + paddingPixels
        val combinedHeight = leftBitmap.height
        
        Log.d("PdfViewerActivity", "Combined will be: ${combinedWidth}x${combinedHeight}")
        Log.d("PdfViewerActivity", "=====================================")
        
        val combinedBitmap = Bitmap.createBitmap(
            combinedWidth,
            combinedHeight,
            Bitmap.Config.ARGB_8888
        )
        
        val combinedCanvas = Canvas(combinedBitmap)
        combinedCanvas.drawColor(android.graphics.Color.WHITE)
        
        // Draw left page
        combinedCanvas.drawBitmap(leftBitmap, 0f, 0f, null)
        
        // Right side remains empty (white background already drawn)
        
        Log.d("PdfViewerActivity", "Combined page with empty right side successfully")
        
        return combinedBitmap
    }
    
    private suspend fun renderSinglePageOnLeft(pageIndex: Int): Bitmap {
        Log.d("PdfViewerActivity", "Starting renderSinglePageOnLeft for page $pageIndex")
        
        // Open the page
        val page = try {
            pdfRenderer?.openPage(pageIndex)
        } catch (e: Exception) {
            Log.e("PdfViewerActivity", "Failed to open page $pageIndex", e)
            return renderSinglePage(pageIndex)
        }
        
        if (page == null) {
            Log.e("PdfViewerActivity", "Page is null")
            return renderSinglePage(pageIndex)
        }
        
        try {
            Log.d("PdfViewerActivity", "Page (${pageIndex}): ${page.width}x${page.height}, aspect ratio: ${page.width.toFloat() / page.height.toFloat()}")
            
            // Create original-size bitmap for the page
            val pageBitmap = Bitmap.createBitmap(page.width, page.height, Bitmap.Config.ARGB_8888)
            pageBitmap.eraseColor(android.graphics.Color.WHITE)
            page.render(pageBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)
            
            page.close()
            
            // Create combined bitmap with empty right side (same size as two-page layout)
            val paddingPixels = (pageBitmap.width * currentCenterPadding).toInt()
            val combinedWidth = pageBitmap.width * 2 + paddingPixels
            val combinedHeight = pageBitmap.height
            val combinedBitmap = Bitmap.createBitmap(combinedWidth, combinedHeight, Bitmap.Config.ARGB_8888)
            
            val combinedCanvas = Canvas(combinedBitmap)
            combinedCanvas.drawColor(android.graphics.Color.WHITE)
            combinedCanvas.drawBitmap(pageBitmap, 0f, 0f, null)
            // Right side remains empty
            
            // Calculate scale for the combined layout
            val combinedAspectRatio = combinedWidth.toFloat() / combinedHeight.toFloat()
            val screenAspectRatio = screenWidth.toFloat() / screenHeight.toFloat()
            
            val scale = if (combinedAspectRatio > screenAspectRatio) {
                screenWidth.toFloat() / combinedWidth.toFloat()
            } else {
                screenHeight.toFloat() / combinedHeight.toFloat()
            }
            
            // Apply high-resolution multiplier
            val finalScale = (scale * 2.5f).coerceIn(1.0f, 4.0f)
            
            Log.d("PdfViewerActivity", "=== SINGLE PAGE ON LEFT SCALING ===")
            Log.d("PdfViewerActivity", "Combined: ${combinedWidth}x${combinedHeight}, aspect ratio: $combinedAspectRatio")
            Log.d("PdfViewerActivity", "Screen: ${screenWidth}x${screenHeight}, aspect ratio: $screenAspectRatio")
            Log.d("PdfViewerActivity", "Base scale: $scale, Final scale: $finalScale")
            Log.d("PdfViewerActivity", "===================================")
            
            // Create final high-resolution bitmap
            val finalWidth = (combinedWidth * finalScale).toInt()
            val finalHeight = (combinedHeight * finalScale).toInt()
            val finalBitmap = Bitmap.createBitmap(finalWidth, finalHeight, Bitmap.Config.ARGB_8888)
            
            val finalCanvas = Canvas(finalBitmap)
            finalCanvas.drawColor(android.graphics.Color.WHITE)
            
            // Scale and draw the combined bitmap
            val scaleMatrix = android.graphics.Matrix()
            scaleMatrix.setScale(finalScale, finalScale)
            finalCanvas.drawBitmap(combinedBitmap, scaleMatrix, null)
            
            // Clean up intermediate bitmaps
            pageBitmap.recycle()
            combinedBitmap.recycle()
            
            // Apply clipping if needed
            return applyDisplaySettings(finalBitmap, true)
            
        } catch (e: Exception) {
            Log.e("PdfViewerActivity", "Error in renderSinglePageOnLeft", e)
            try {
                page.close()
            } catch (closeError: Exception) {
                Log.w("PdfViewerActivity", "Page already closed or error closing: ${closeError.message}")
            }
            throw e
        }
    }
    
    private suspend fun renderSinglePage(index: Int): Bitmap {
        currentPage = pdfRenderer?.openPage(index)
        val page = currentPage ?: throw Exception("Failed to open page $index")
        
        // Calculate high-resolution dimensions
        val scale = calculateOptimalScale(page.width, page.height)
        val renderWidth = (page.width * scale).toInt()
        val renderHeight = (page.height * scale).toInt()
        
        val originalPageRatio = page.width.toFloat() / page.height.toFloat()
        val renderedPageRatio = renderWidth.toFloat() / renderHeight.toFloat()
        
        Log.d("PdfViewerActivity", "=== SINGLE PAGE RENDER ===")
        Log.d("PdfViewerActivity", "Original PDF page: ${page.width}x${page.height}, aspect ratio: $originalPageRatio")
        Log.d("PdfViewerActivity", "Rendered bitmap: ${renderWidth}x${renderHeight}, aspect ratio: $renderedPageRatio")
        Log.d("PdfViewerActivity", "Scale: $scale, aspect ratio preserved: ${kotlin.math.abs(originalPageRatio - renderedPageRatio) < 0.001f}")
        Log.d("PdfViewerActivity", "==========================")
        
        val bitmap = Bitmap.createBitmap(
            renderWidth,
            renderHeight,
            Bitmap.Config.ARGB_8888
        )
        
        // Fill with white background
        val canvas = Canvas(bitmap)
        canvas.drawColor(android.graphics.Color.WHITE)
        
        // Create transform matrix for scaling
        val matrix = android.graphics.Matrix()
        matrix.setScale(scale, scale)
        
        // Render with scaling (Matrix only to preserve aspect ratio)
        page.render(bitmap, null, matrix, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)
        
        // Apply clipping and padding if needed
        return applyDisplaySettings(bitmap, false)
    }
    
    private suspend fun renderTwoPages(leftPageIndex: Int): Bitmap {
        Log.d("PdfViewerActivity", "Starting renderTwoPages for pages $leftPageIndex and ${leftPageIndex + 1}")
        
        // Open left page
        val leftPage = try {
            pdfRenderer?.openPage(leftPageIndex)
        } catch (e: Exception) {
            Log.e("PdfViewerActivity", "Failed to open left page $leftPageIndex", e)
            return renderSinglePage(leftPageIndex)
        }
        
        if (leftPage == null) {
            Log.e("PdfViewerActivity", "Left page is null")
            return renderSinglePage(leftPageIndex)
        }
        
        try {
            // Log individual page dimensions
            Log.d("PdfViewerActivity", "=== INDIVIDUAL PAGE ASPECT RATIOS ===")
            Log.d("PdfViewerActivity", "Left page (${leftPageIndex}): ${leftPage.width}x${leftPage.height}, aspect ratio: ${leftPage.width.toFloat() / leftPage.height.toFloat()}")
            
            // Create original-size bitmap for left page (no scaling yet)
            val leftBitmap = Bitmap.createBitmap(leftPage.width, leftPage.height, Bitmap.Config.ARGB_8888)
            leftBitmap.eraseColor(android.graphics.Color.WHITE)
            leftPage.render(leftBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)
            
            leftPage.close()
            
            // Open right page
            val rightPage = try {
                pdfRenderer?.openPage(leftPageIndex + 1)
            } catch (e: Exception) {
                Log.e("PdfViewerActivity", "Failed to open right page ${leftPageIndex + 1}", e)
                return leftBitmap // Return just the left page
            }
            
            if (rightPage == null) {
                Log.e("PdfViewerActivity", "Right page is null")
                return leftBitmap // Return just the left page
            }
            
            try {
                Log.d("PdfViewerActivity", "Right page (${leftPageIndex + 1}): ${rightPage.width}x${rightPage.height}, aspect ratio: ${rightPage.width.toFloat() / rightPage.height.toFloat()}")
                Log.d("PdfViewerActivity", "=====================================")
                
                // Create original-size bitmap for right page (no scaling yet)
                val rightBitmap = Bitmap.createBitmap(rightPage.width, rightPage.height, Bitmap.Config.ARGB_8888)
                rightBitmap.eraseColor(android.graphics.Color.WHITE)
                rightPage.render(rightBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)
                
                rightPage.close()
                
                // Combine two pages side by side with center padding (original resolution)
                val paddingPixels = (leftBitmap.width * currentCenterPadding).toInt()
                val combinedWidth = leftBitmap.width + rightBitmap.width + paddingPixels
                val combinedHeight = maxOf(leftBitmap.height, rightBitmap.height)
                val combinedBitmap = Bitmap.createBitmap(combinedWidth, combinedHeight, Bitmap.Config.ARGB_8888)
                
                val combinedCanvas = Canvas(combinedBitmap)
                combinedCanvas.drawColor(android.graphics.Color.WHITE)
                combinedCanvas.drawBitmap(leftBitmap, 0f, 0f, null)
                
                // Draw right page with center padding offset
                val rightPageX = leftBitmap.width.toFloat() + paddingPixels
                combinedCanvas.drawBitmap(rightBitmap, rightPageX, 0f, null)
                
                Log.d("PdfViewerActivity", "Combined pages with ${(currentCenterPadding * 100).toInt()}% center padding")
                
                // Calculate scale based on combined bitmap aspect ratio vs screen
                val combinedAspectRatio = combinedWidth.toFloat() / combinedHeight.toFloat()
                val screenAspectRatio = screenWidth.toFloat() / screenHeight.toFloat()
                
                val scale = if (combinedAspectRatio > screenAspectRatio) {
                    // Combined bitmap is wider than screen -> scale by width
                    screenWidth.toFloat() / combinedWidth.toFloat()
                } else {
                    // Combined bitmap is taller than screen -> scale by height
                    screenHeight.toFloat() / combinedHeight.toFloat()
                }
                
                // Apply high-resolution multiplier (2-4x for crisp rendering)
                val finalScale = (scale * 2.5f).coerceIn(1.0f, 4.0f)
                
                Log.d("PdfViewerActivity", "=== TWO PAGE SCALING ===")
                Log.d("PdfViewerActivity", "Combined: ${combinedWidth}x${combinedHeight}, aspect ratio: $combinedAspectRatio")
                Log.d("PdfViewerActivity", "Screen: ${screenWidth}x${screenHeight}, aspect ratio: $screenAspectRatio")
                Log.d("PdfViewerActivity", "Base scale: $scale, Final scale: $finalScale")
                Log.d("PdfViewerActivity", "========================")
                
                // Create final high-resolution bitmap
                val finalWidth = (combinedWidth * finalScale).toInt()
                val finalHeight = (combinedHeight * finalScale).toInt()
                val finalBitmap = Bitmap.createBitmap(finalWidth, finalHeight, Bitmap.Config.ARGB_8888)
                
                val finalCanvas = Canvas(finalBitmap)
                finalCanvas.drawColor(android.graphics.Color.WHITE)
                
                // Scale and draw the combined bitmap
                val scaleMatrix = android.graphics.Matrix()
                scaleMatrix.setScale(finalScale, finalScale)
                finalCanvas.drawBitmap(combinedBitmap, scaleMatrix, null)
                
                // Clean up intermediate bitmaps
                leftBitmap.recycle()
                rightBitmap.recycle()
                combinedBitmap.recycle()
                
                // Apply clipping and padding if needed
                return applyDisplaySettings(finalBitmap, true)
                
            } finally {
                try {
                    rightPage.close()
                } catch (e: Exception) {
                    Log.w("PdfViewerActivity", "Right page already closed or error closing: ${e.message}")
                }
            }
            
        } catch (e: Exception) {
            Log.e("PdfViewerActivity", "Error in renderTwoPages", e)
            try {
                leftPage.close()
            } catch (closeError: Exception) {
                Log.w("PdfViewerActivity", "Left page already closed or error closing: ${closeError.message}")
            }
            return renderSinglePage(leftPageIndex)
        }
    }
    
    private fun calculateOptimalScale(pageWidth: Int, pageHeight: Int, forTwoPageMode: Boolean = false): Float {
        // Îëê ÌéòÏù¥ÏßÄ Î™®ÎìúÏóêÏÑúÎäî Ìï©Ï≥êÏßÑ ÌÅ¨Í∏∞ Í∏∞Ï§ÄÏúºÎ°ú Í≥ÑÏÇ∞
        val effectiveWidth = if (forTwoPageMode) pageWidth * 2 else pageWidth
        val effectiveHeight = pageHeight
        
        // ÌôîÎ©¥ ÌÅ¨Í∏∞Ïóê ÎßûÎäî ÏµúÏ†Å Ïä§ÏºÄÏùº Í≥ÑÏÇ∞
        val screenRatio = screenWidth.toFloat() / screenHeight.toFloat()
        val pageRatio = effectiveWidth.toFloat() / effectiveHeight.toFloat()
        
        val scale = if (pageRatio > screenRatio) {
            // ÌéòÏù¥ÏßÄÍ∞Ä ÌôîÎ©¥Î≥¥Îã§ Í∞ÄÎ°úÍ∞Ä Í∏¥ Í≤ΩÏö∞ - Í∞ÄÎ°ú Í∏∞Ï§ÄÏúºÎ°ú ÎßûÏ∂§
            screenWidth.toFloat() / effectiveWidth.toFloat()
        } else {
            // ÌéòÏù¥ÏßÄÍ∞Ä ÌôîÎ©¥Î≥¥Îã§ ÏÑ∏Î°úÍ∞Ä Í∏¥ Í≤ΩÏö∞ - ÏÑ∏Î°ú Í∏∞Ï§ÄÏúºÎ°ú ÎßûÏ∂§  
            screenHeight.toFloat() / effectiveHeight.toFloat()
        }
        
        // ÏµúÏÜå 2Î∞∞, ÏµúÎåÄ 4Î∞∞ Ïä§ÏºÄÏùºÎßÅ (Í≥†Ìï¥ÏÉÅÎèÑ Î≥¥Ïû•)
        val finalScale = (scale * 2.0f).coerceIn(2.0f, 4.0f)
        
        Log.d("PdfViewerActivity", "=== SCALE CALCULATION ===")
        Log.d("PdfViewerActivity", "Input: Page ${pageWidth}x${pageHeight}, forTwoPageMode=$forTwoPageMode")
        Log.d("PdfViewerActivity", "Effective: ${effectiveWidth}x${effectiveHeight}")
        Log.d("PdfViewerActivity", "Screen: ${screenWidth}x${screenHeight}")
        Log.d("PdfViewerActivity", "Screen ratio: $screenRatio, Page ratio: $pageRatio")
        Log.d("PdfViewerActivity", "Scale by ${if (pageRatio > screenRatio) "WIDTH" else "HEIGHT"}: $scale")
        Log.d("PdfViewerActivity", "Final scale: $finalScale")
        Log.d("PdfViewerActivity", "==========================")
        
        return finalScale
    }
    
    private fun setImageViewMatrix(bitmap: Bitmap) {
        val imageMatrix = android.graphics.Matrix()
        
        // Calculate scale to fit the image in the view while preserving aspect ratio
        val viewWidth = binding.pdfView.width
        val viewHeight = binding.pdfView.height
        
        if (viewWidth == 0 || viewHeight == 0) {
            // View not yet measured, set later
            binding.pdfView.post {
                setImageViewMatrix(bitmap)
            }
            return
        }
        
        val bitmapWidth = bitmap.width
        val bitmapHeight = bitmap.height
        
        // Calculate original aspect ratio
        val originalAspectRatio = bitmapWidth.toFloat() / bitmapHeight.toFloat()
        
        val scaleX = viewWidth.toFloat() / bitmapWidth.toFloat()
        val scaleY = viewHeight.toFloat() / bitmapHeight.toFloat()
        
        // Use the smaller scale to ensure the whole image fits
        val scale = minOf(scaleX, scaleY)
        
        // Calculate translation to center the image
        val scaledWidth = bitmapWidth * scale
        val scaledHeight = bitmapHeight * scale
        val dx = (viewWidth - scaledWidth) / 2f
        val dy = (viewHeight - scaledHeight) / 2f
        
        // Calculate final displayed aspect ratio
        val finalAspectRatio = scaledWidth / scaledHeight
        
        imageMatrix.setScale(scale, scale)
        imageMatrix.postTranslate(dx, dy)
        
        binding.pdfView.imageMatrix = imageMatrix
        
        Log.d("PdfViewerActivity", "=== ASPECT RATIO CHECK ===")
        Log.d("PdfViewerActivity", "Original bitmap: ${bitmapWidth}x${bitmapHeight}, aspect ratio: $originalAspectRatio")
        Log.d("PdfViewerActivity", "Final displayed: ${scaledWidth}x${scaledHeight}, aspect ratio: $finalAspectRatio")
        Log.d("PdfViewerActivity", "Aspect ratio preserved: ${kotlin.math.abs(originalAspectRatio - finalAspectRatio) < 0.001f}")
        Log.d("PdfViewerActivity", "ImageView matrix: scale=$scale, translate=($dx, $dy)")
        Log.d("PdfViewerActivity", "========================")
    }
    
    private fun updatePageInfo() {
        val fileInfo = if (fileNameList.isNotEmpty()) {
            "[${currentFileIndex + 1}/${filePathList.size}] ${fileNameList[currentFileIndex]} - "
        } else {
            "$pdfFileName - "
        }
        
        val pageInfo = if (isTwoPageMode && pageIndex + 1 < pageCount) {
            // Two page mode: show "1-2 / 10" format
            "${pageIndex + 1}-${pageIndex + 2} / $pageCount"
        } else {
            // Single page mode: show "1 / 10" format
            "${pageIndex + 1} / $pageCount"
        }
        
        // Add cache info for debugging (only show if cache exists)
        val cacheInfo = pageCache?.let { cache ->
            " [${cache.getCacheInfo()}]"
        } ?: ""
        
        binding.pageInfo.text = "$fileInfo$pageInfo$cacheInfo"
    }
    
    private fun loadNextFile() {
        if (currentFileIndex < filePathList.size - 1) {
            currentFileIndex++
            loadFile(filePathList[currentFileIndex], fileNameList[currentFileIndex])
        }
    }
    
    private fun loadPreviousFile() {
        if (currentFileIndex > 0) {
            currentFileIndex--
            loadFile(filePathList[currentFileIndex], fileNameList[currentFileIndex], true)
        }
    }
    
    private fun loadFileWithTargetPage(filePath: String, fileName: String, targetPage: Int, originalMode: CollaborationMode) {
        // Close current PDF
        Log.d("PdfViewerActivity", "Closing current PDF resources for collaboration file change...")
        try {
            currentPage?.close()
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "Current page already closed or error closing: ${e.message}")
        }
        currentPage = null
        
        try {
            pdfRenderer?.close()
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "PdfRenderer already closed or error closing: ${e.message}")
        }
        pdfRenderer = null
        
        pdfFilePath = filePath
        pdfFileName = fileName
        
        CoroutineScope(Dispatchers.IO).launch {
            try {
                Log.d("PdfViewerActivity", "Loading file for collaboration: $filePath")
                val file = File(pdfFilePath)
                
                if (!file.exists() || !file.canRead()) {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@PdfViewerActivity, "ÌååÏùºÏùÑ ÏùΩÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: $fileName", Toast.LENGTH_LONG).show()
                        collaborationMode = originalMode
                        finish()
                    }
                    return@launch
                }
                
                val fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)
                pdfRenderer = PdfRenderer(fileDescriptor)
                pageCount = pdfRenderer?.pageCount ?: 0
                
                withContext(Dispatchers.Main) {
                    if (pageCount > 0) {
                        // Initialize page cache for new file
                        pageCache?.destroy()
                        
                        val firstPage = pdfRenderer!!.openPage(0)
                        val calculatedScale = calculateOptimalScale(firstPage.width, firstPage.height)
                        firstPage.close()
                        
                        pageCache = PageCache(pdfRenderer!!, screenWidth, screenHeight)
                        
                        // Register settings callback immediately after PageCache creation
                        registerSettingsCallback()
                        
                        Log.d("PdfViewerActivity", "PageCache Ïû¨Ï¥àÍ∏∞Ìôî ÏôÑÎ£å for collaboration file change")
                        
                        checkAndSetTwoPageMode {
                            // Recalculate scale based on the determined mode
                            val firstPage = pdfRenderer!!.openPage(0)
                            val finalScale = calculateOptimalScale(firstPage.width, firstPage.height, isTwoPageMode)
                            firstPage.close()
                            
                            Log.d("PdfViewerActivity", "Final scale for collaboration file change, two-page mode $isTwoPageMode: $finalScale")
                            
                            // Clear cache and update settings to ensure clean state
                            pageCache?.clear()
                            pageCache?.updateSettings(isTwoPageMode, finalScale)
                            
                            // Navigate to target page (convert from 1-based to 0-based)
                            val targetIndex = (targetPage - 1).coerceIn(0, pageCount - 1)
                            showPage(targetIndex)
                            
                            // Restore collaboration mode
                            collaborationMode = originalMode
                            
                            Log.d("PdfViewerActivity", "üéº Ïó∞Ï£ºÏûê Î™®Îìú: ÌååÏùº '$fileName' Î°úÎìú ÏôÑÎ£å, ÌéòÏù¥ÏßÄ $targetPage Î°ú Ïù¥Îèô ÏôÑÎ£å")
                        }
                    } else {
                        Toast.makeText(this@PdfViewerActivity, "Îπà PDF ÌååÏùºÏûÖÎãàÎã§: $fileName", Toast.LENGTH_SHORT).show()
                        collaborationMode = originalMode
                        finish()
                    }
                }
            } catch (e: Exception) {
                Log.e("PdfViewerActivity", "Error loading file for collaboration", e)
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@PdfViewerActivity, "ÌååÏùº Î°úÎìú Ïã§Ìå®: ${e.message}", Toast.LENGTH_LONG).show()
                    collaborationMode = originalMode
                    finish()
                }
            }
        }
    }
    
    private fun loadFile(filePath: String, fileName: String, goToLastPage: Boolean = false) {
        // Close current PDF
        Log.d("PdfViewerActivity", "Closing current PDF resources...")
        try {
            currentPage?.close()
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "Current page already closed or error closing: ${e.message}")
        }
        currentPage = null
        Log.d("PdfViewerActivity", "Current page closed")
        
        try {
            pdfRenderer?.close()
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "PdfRenderer already closed or error closing: ${e.message}")
        }
        pdfRenderer = null
        Log.d("PdfViewerActivity", "PdfRenderer closed")
        
        pdfFilePath = filePath
        pdfFileName = fileName
        
        CoroutineScope(Dispatchers.IO).launch {
            try {
                Log.d("PdfViewerActivity", "Loading new file: $filePath")
                val file = File(pdfFilePath)
                
                Log.d("PdfViewerActivity", "New file exists: ${file.exists()}")
                Log.d("PdfViewerActivity", "New file path: ${file.absolutePath}")
                
                // ÌååÏùº Ï°¥Ïû¨ ÌôïÏù∏
                if (!file.exists()) {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@PdfViewerActivity, "ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: $fileName", Toast.LENGTH_LONG).show()
                        // ÌååÏùº Î™©Î°ùÏùÑ Îã§Ïãú Î°úÎìúÌïòÍ≥† ÌòÑÏû¨ Ïï°Ìã∞ÎπÑÌã∞ Ï¢ÖÎ£å
                        finish()
                    }
                    return@launch
                }
                
                if (!file.canRead()) {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@PdfViewerActivity, "ÌååÏùºÏùÑ ÏùΩÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: $fileName", Toast.LENGTH_LONG).show()
                        finish()
                    }
                    return@launch
                }
                
                Log.d("PdfViewerActivity", "File permissions OK, creating ParcelFileDescriptor...")
                val fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)
                Log.d("PdfViewerActivity", "ParcelFileDescriptor created successfully")
                
                Log.d("PdfViewerActivity", "Creating PdfRenderer...")
                pdfRenderer = PdfRenderer(fileDescriptor)
                Log.d("PdfViewerActivity", "PdfRenderer created successfully")
                
                pageCount = pdfRenderer?.pageCount ?: 0
                Log.d("PdfViewerActivity", "Page count retrieved: $pageCount")
                
                withContext(Dispatchers.Main) {
                    if (pageCount > 0) {
                        // Initialize page cache for new file with proper scale calculation
                        pageCache?.destroy() // Clean up previous cache
                        
                        // Calculate proper scale based on first page
                        val firstPage = pdfRenderer!!.openPage(0)
                        val calculatedScale = calculateOptimalScale(firstPage.width, firstPage.height)
                        firstPage.close()
                        
                        pageCache = PageCache(pdfRenderer!!, screenWidth, screenHeight)
                        
                        // Register settings callback immediately after PageCache creation
                        registerSettingsCallback()
                        
                        Log.d("PdfViewerActivity", "PageCache Ïû¨Ï¥àÍ∏∞Ìôî ÏôÑÎ£å for $fileName (scale: $calculatedScale)")
                        
                        // Check two-page mode for this new file, then show the page
                        checkAndSetTwoPageMode {
                            // Recalculate scale based on the determined mode
                            val firstPage = pdfRenderer!!.openPage(0)
                            val finalScale = calculateOptimalScale(firstPage.width, firstPage.height, isTwoPageMode)
                            firstPage.close()
                            
                            Log.d("PdfViewerActivity", "Final scale for loadFile, two-page mode $isTwoPageMode: $finalScale")
                            
                            // Clear cache and update settings to ensure clean state
                            pageCache?.clear()
                            pageCache?.updateSettings(isTwoPageMode, finalScale)
                            
                            val targetPage = if (goToLastPage) pageCount - 1 else 0
                            showPage(targetPage)
                            
                            // Broadcast file change if in conductor mode
                            if (collaborationMode == CollaborationMode.CONDUCTOR) {
                                // Add file to server first
                                globalCollaborationManager.addFileToServer(pdfFileName, pdfFilePath)
                                // Then broadcast the change with the target page number
                                val actualPageNumber = targetPage + 1 // Convert to 1-based index
                                globalCollaborationManager.broadcastFileChange(pdfFileName, actualPageNumber)
                            }
                        }
                    } else {
                        Toast.makeText(this@PdfViewerActivity, "Îπà PDF ÌååÏùºÏûÖÎãàÎã§: $fileName", Toast.LENGTH_SHORT).show()
                        finish()
                    }
                }
            } catch (e: Exception) {
                Log.e("PdfViewerActivity", "Exception in loadFile for $fileName", e)
                Log.e("PdfViewerActivity", "Exception type: ${e::class.java.simpleName}")
                Log.e("PdfViewerActivity", "Exception message: ${e.message}")
                e.printStackTrace()
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@PdfViewerActivity, "ÌååÏùº Ïó¥Í∏∞ Ïã§Ìå®: $fileName - ${e.message}", Toast.LENGTH_LONG).show()
                    finish()
                }
            }
        }
    }
    
    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        when (keyCode) {
            KeyEvent.KEYCODE_DPAD_LEFT -> {
                if (isNavigationGuideVisible) {
                    if (navigationGuideType == "start" && currentFileIndex > 0) {
                        // Ï≤´ ÌéòÏù¥ÏßÄ ÏïàÎÇ¥ÏóêÏÑú ÏôºÏ™Ω ÌÇ§ -> Ïù¥Ï†Ñ ÌååÏùºÎ°ú Ïù¥Îèô
                        hideNavigationGuide()
                        loadPreviousFile()
                        return true
                    }
                    // ÏïàÎÇ¥Í∞Ä ÌëúÏãúÎêú ÏÉÅÌÉúÏóêÏÑúÎäî ÏùºÎ∞ò ÌéòÏù¥ÏßÄ Ïù¥Îèô Ï∞®Îã®
                    return true
                } else if (pageIndex > 0) {
                    val nextPageIndex = if (isTwoPageMode) pageIndex - 2 else pageIndex - 1
                    showPage(maxOf(0, nextPageIndex))
                    return true
                } else {
                    // Ï≤´ ÌéòÏù¥ÏßÄÏóêÏÑú ÏïàÎÇ¥ ÌëúÏãú
                    showStartOfFileGuide()
                    return true
                }
            }
            KeyEvent.KEYCODE_DPAD_RIGHT -> {
                if (isNavigationGuideVisible) {
                    if (navigationGuideType == "end" && currentFileIndex < filePathList.size - 1) {
                        // ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄ ÏïàÎÇ¥ÏóêÏÑú Ïò§Î•∏Ï™Ω ÌÇ§ -> Îã§Ïùå ÌååÏùºÎ°ú Ïù¥Îèô
                        hideNavigationGuide()
                        loadNextFile()
                        return true
                    }
                    // ÏïàÎÇ¥Í∞Ä ÌëúÏãúÎêú ÏÉÅÌÉúÏóêÏÑúÎäî ÏùºÎ∞ò ÌéòÏù¥ÏßÄ Ïù¥Îèô Ï∞®Îã®
                    return true
                } else {
                    val nextPageIndex = if (isTwoPageMode) pageIndex + 2 else pageIndex + 1
                    if (nextPageIndex < pageCount) {
                        showPage(nextPageIndex)
                        return true
                    } else {
                        // ÎßàÏßÄÎßâ ÌéòÏù¥ÏßÄÏóêÏÑú ÏïàÎÇ¥ ÌëúÏãú
                        showEndOfFileGuide()
                        return true
                    }
                }
            }
            KeyEvent.KEYCODE_BACK, KeyEvent.KEYCODE_ESCAPE -> {
                // ÏßÄÌúòÏûê Î™®ÎìúÏóêÏÑú Îí§Î°úÍ∞ÄÍ∏∞ Ïãú Ïó∞Ï£ºÏûêÏóêÍ≤å ÏïåÎ¶º
                if (collaborationMode == CollaborationMode.CONDUCTOR) {
                    Log.d("PdfViewerActivity", "üéµ ÏßÄÌúòÏûê Î™®Îìú: Îí§Î°úÍ∞ÄÍ∏∞ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏")
                    globalCollaborationManager.broadcastBackToList()
                }
                finish()
                return true
            }
            KeyEvent.KEYCODE_DPAD_CENTER, KeyEvent.KEYCODE_ENTER -> {
                if (event?.action == KeyEvent.ACTION_DOWN && event.repeatCount == 0) {
                    // Start long press detection
                    isLongPressing = true
                    longPressHandler.postDelayed(longPressRunnable, longPressDelay)
                }
                return true
            }
            KeyEvent.KEYCODE_MENU -> {
                // Î©îÎâ¥ ÌÇ§Î°ú ÌéòÏù¥ÏßÄ Ï†ïÎ≥¥ ÌëúÏãú/Ïà®ÍπÄ ÌÜ†Í∏Ä
                if (binding.pageInfo.alpha > 0.5f) {
                    binding.pageInfo.animate().alpha(0.3f).duration = 200
                } else {
                    binding.pageInfo.animate().alpha(1f).duration = 200
                }
                return true
            }
        }
        return super.onKeyDown(keyCode, event)
    }
    
    override fun onKeyUp(keyCode: Int, event: KeyEvent?): Boolean {
        when (keyCode) {
            KeyEvent.KEYCODE_DPAD_CENTER, KeyEvent.KEYCODE_ENTER -> {
                // Cancel long press and handle short press
                longPressHandler.removeCallbacks(longPressRunnable)
                
                if (isLongPressing && event?.isCanceled != true) {
                    // This was a short press, not a long press
                    if (isNavigationGuideVisible) {
                        // ÏïàÎÇ¥Í∞Ä ÌëúÏãúÎêòÏñ¥ ÏûàÏúºÎ©¥ Ïà®Í∏∞Í∏∞
                        hideNavigationGuide()
                    } else {
                        // Toggle page info visibility
                        if (binding.pageInfo.alpha > 0.5f) {
                            binding.pageInfo.animate().alpha(0.3f).duration = 200
                        } else {
                            binding.pageInfo.animate().alpha(1f).duration = 200
                        }
                    }
                }
                
                isLongPressing = false
                return true
            }
        }
        return super.onKeyUp(keyCode, event)
    }
    
    // handleEndOfFile()Í≥º handleStartOfFile() Î©îÏÑúÎìú ÏÇ≠Ï†ú - Îçî Ïù¥ÏÉÅ ÌïÑÏöîÌïòÏßÄ ÏïäÏùå
    
    private fun showEndOfFileGuide() {
        val hasNextFile = currentFileIndex < filePathList.size - 1
        
        // ÏôºÏ™Ω ÎÑ§ÎπÑÍ≤åÏù¥ÏÖòÏùÄ Ïà®ÍπÄ (Îçî Ïù¥ÏÉÅ Î™©Î°ùÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞ ÏóÜÏùå)
        binding.leftNavigation.visibility = View.GONE
        
        // Ïò§Î•∏Ï™Ω ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÏÑ§Ï†ï (Îã§Ïùå ÌååÏùº ÎòêÎäî ÏóÜÏùå)
        if (hasNextFile) {
            binding.rightNavigation.visibility = View.VISIBLE
            binding.rightNavText.text = "Îã§Ïùå ÌååÏùº"
            binding.rightNavSubText.text = fileNameList[currentFileIndex + 1]
        } else {
            binding.rightNavigation.visibility = View.GONE
        }
        
        showNavigationGuide("end")
    }
    
    private fun showStartOfFileGuide() {
        val hasPreviousFile = currentFileIndex > 0
        
        // ÏôºÏ™Ω ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò ÏÑ§Ï†ï (Ïù¥Ï†Ñ ÌååÏùº ÎòêÎäî ÏóÜÏùå)
        if (hasPreviousFile) {
            binding.leftNavigation.visibility = View.VISIBLE
            binding.leftNavText.text = "Ïù¥Ï†Ñ ÌååÏùº"
            binding.leftNavSubText.text = fileNameList[currentFileIndex - 1]
        } else {
            binding.leftNavigation.visibility = View.GONE
        }
        
        // Ïò§Î•∏Ï™Ω ÎÑ§ÎπÑÍ≤åÏù¥ÏÖòÏùÄ Ïà®ÍπÄ (Îçî Ïù¥ÏÉÅ Î™©Î°ùÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞ ÏóÜÏùå)
        binding.rightNavigation.visibility = View.GONE
        
        showNavigationGuide("start")
    }
    
    private fun showNavigationGuide(type: String) {
        isNavigationGuideVisible = true
        navigationGuideType = type
        binding.navigationGuide.visibility = View.VISIBLE
        binding.navigationGuide.animate().alpha(1f).duration = 300
        
        // 3Ï¥à ÌõÑ ÏûêÎèôÏúºÎ°ú Ïà®Í∏∞Í∏∞
        binding.navigationGuide.postDelayed({
            hideNavigationGuide()
        }, 3000)
    }
    
    private fun hideNavigationGuide() {
        if (isNavigationGuideVisible) {
            isNavigationGuideVisible = false
            navigationGuideType = ""
            binding.navigationGuide.animate().alpha(0f).withEndAction {
                binding.navigationGuide.visibility = View.GONE
                binding.leftNavigation.visibility = View.GONE
                binding.rightNavigation.visibility = View.GONE
            }.duration = 300
        }
    }
    
    private fun initializeCollaboration() {
        // Get current collaboration mode from global manager
        collaborationMode = globalCollaborationManager.getCurrentMode()
        
        Log.d("PdfViewerActivity", "Collaboration mode: $collaborationMode")
        
        when (collaborationMode) {
            CollaborationMode.CONDUCTOR -> {
                setupConductorCallbacks()
                updateCollaborationStatus()
            }
            CollaborationMode.PERFORMER -> {
                setupPerformerCallbacks()
                updateCollaborationStatus()
            }
            CollaborationMode.NONE -> {
                binding.collaborationStatus.visibility = View.GONE
            }
        }
    }
    
    private fun setupConductorCallbacks() {
        globalCollaborationManager.setOnServerClientConnected { clientId, deviceName ->
            runOnUiThread {
                Log.d("PdfViewerActivity", "üéµ ÏßÄÌúòÏûê Î™®Îìú: ÏÉà Ïó∞Ï£ºÏûê Ïó∞Í≤∞Îê® - $deviceName")
                Toast.makeText(this@PdfViewerActivity, "$deviceName Ïó∞Í≤∞Îê®", Toast.LENGTH_SHORT).show()
                updateCollaborationStatus()
                
                // Send current file and page to newly connected client
                Log.d("PdfViewerActivity", "üéµ ÏßÄÌúòÏûê Î™®Îìú: ÌòÑÏû¨ ÏÉÅÌÉúÎ•º ÏÉà Ïó∞Ï£ºÏûêÏóêÍ≤å Ï†ÑÏÜ° Ï§ë...")
                // Add file to server so performers can download if needed
                globalCollaborationManager.addFileToServer(pdfFileName, pdfFilePath)
                
                val actualPageNumber = if (isTwoPageMode) pageIndex + 1 else pageIndex + 1
                globalCollaborationManager.broadcastFileChange(pdfFileName, actualPageNumber)
            }
        }
        
        globalCollaborationManager.setOnServerClientDisconnected { clientId ->
            runOnUiThread {
                Toast.makeText(this@PdfViewerActivity, "Í∏∞Í∏∞ Ïó∞Í≤∞ Ìï¥Ï†úÎê®", Toast.LENGTH_SHORT).show()
                updateCollaborationStatus()
            }
        }
    }
    
    private fun setupPerformerCallbacks() {
        globalCollaborationManager.setOnPageChangeReceived { page, file ->
            runOnUiThread {
                if (file == pdfFileName) {
                    handleRemotePageChange(page)
                }
            }
        }
        
        globalCollaborationManager.setOnFileChangeReceived { file, page ->
            runOnUiThread {
                handleRemoteFileChange(file, page)
            }
        }
        
        globalCollaborationManager.setOnClientConnectionStatusChanged { isConnected ->
            runOnUiThread {
                val status = if (isConnected) "Ïó∞Í≤∞Îê®" else "Ïó∞Í≤∞ ÎÅäÍπÄ"
                Toast.makeText(this@PdfViewerActivity, "ÏßÄÌúòÏûê: $status", Toast.LENGTH_SHORT).show()
                updateCollaborationStatus()
            }
        }
        
        globalCollaborationManager.setOnBackToListReceived {
            runOnUiThread {
                Log.d("PdfViewerActivity", "üéº Ïó∞Ï£ºÏûê Î™®Îìú: Îí§Î°úÍ∞ÄÍ∏∞ Ïã†Ìò∏ ÏàòÏã†, ÌååÏùº Î™©Î°ùÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞")
                finish()
            }
        }
    }
    
    private fun handleRemotePageChange(page: Int) {
        // Convert to 0-based index
        val targetIndex = page - 1
        
        Log.d("PdfViewerActivity", "üéº Ïó∞Ï£ºÏûê Î™®Îìú: ÌéòÏù¥ÏßÄ $page Î≥ÄÍ≤Ω Ïã†Ìò∏ ÏàòÏã†Îê® (current file: $pdfFileName, pageCount: $pageCount)")
        
        if (targetIndex >= 0 && targetIndex < pageCount) {
            // Temporarily disable conductor mode to prevent infinite loop
            val originalMode = collaborationMode
            collaborationMode = CollaborationMode.NONE
            
            Log.d("PdfViewerActivity", "üéº Ïó∞Ï£ºÏûê Î™®Îìú: ÌéòÏù¥ÏßÄ $page Î°ú Ïù¥Îèô Ï§ë...")
            showPage(targetIndex)
            
            // Restore original mode
            collaborationMode = originalMode
            
            Log.d("PdfViewerActivity", "üéº Ïó∞Ï£ºÏûê Î™®Îìú: ÌéòÏù¥ÏßÄ $page Î°ú Ïù¥Îèô ÏôÑÎ£å")
        } else {
            Log.w("PdfViewerActivity", "üéº Ïó∞Ï£ºÏûê Î™®Îìú: ÏûòÎ™ªÎêú ÌéòÏù¥ÏßÄ Î≤àÌò∏ $page (Ï¥ù $pageCount ÌéòÏù¥ÏßÄ)")
        }
    }
    
    private fun handleRemoteFileChange(file: String, targetPage: Int) {
        // Check if the requested file exists in our file list
        val fileIndex = fileNameList.indexOf(file)
        
        if (fileIndex >= 0 && fileIndex < filePathList.size) {
            // Load the requested file
            currentFileIndex = fileIndex
            pdfFilePath = filePathList[fileIndex]
            pdfFileName = fileNameList[fileIndex]
            
            // Temporarily disable collaboration to prevent loops
            val originalMode = collaborationMode
            collaborationMode = CollaborationMode.NONE
            
            Log.d("PdfViewerActivity", "üéº Ïó∞Ï£ºÏûê Î™®Îìú: ÌååÏùº '$file' Î°ú Î≥ÄÍ≤Ω Ï§ë... (Î™©Ìëú ÌéòÏù¥ÏßÄ: $targetPage)")
            
            // Load file and navigate to target page after loading completes
            loadFileWithTargetPage(pdfFilePath, pdfFileName, targetPage, originalMode)
            
        } else {
            Log.w("PdfViewerActivity", "üéº Ïó∞Ï£ºÏûê Î™®Îìú: ÏöîÏ≤≠Îêú ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: $file")
            
            // Try to download from conductor
            val conductorAddress = globalCollaborationManager.getConductorAddress()
            if (conductorAddress.isNotEmpty()) {
                showDownloadDialog(file, conductorAddress, targetPage)
            } else {
                Toast.makeText(this, "ÏöîÏ≤≠Îêú ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: $file", Toast.LENGTH_LONG).show()
            }
        }
    }
    
    private fun updateCollaborationStatus() {
        when (collaborationMode) {
            CollaborationMode.CONDUCTOR -> {
                val clientCount = globalCollaborationManager.getConnectedClientCount()
                binding.collaborationStatus.text = "ÏßÄÌúòÏûê: ${clientCount}Î™Ö Ïó∞Í≤∞"
                binding.collaborationStatus.visibility = View.VISIBLE
            }
            CollaborationMode.PERFORMER -> {
                val isConnected = globalCollaborationManager.isClientConnected()
                val status = if (isConnected) "Ïó∞Í≤∞Îê®" else "Ïó∞Í≤∞ ÎÅäÍπÄ"
                binding.collaborationStatus.text = "Ïó∞Ï£ºÏûê: $status"
                binding.collaborationStatus.visibility = View.VISIBLE
            }
            CollaborationMode.NONE -> {
                binding.collaborationStatus.visibility = View.GONE
            }
        }
    }
    
    private fun showDownloadDialog(fileName: String, conductorAddress: String, targetPage: Int = 1) {
        val ipOnly = conductorAddress.split(":").firstOrNull() ?: conductorAddress
        val fileServerUrl = "http://$ipOnly:8090"
        
        AlertDialog.Builder(this)
            .setTitle("ÌååÏùº Îã§Ïö¥Î°úÎìú")
            .setMessage("'$fileName' ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.\nÏßÄÌúòÏûêÎ°úÎ∂ÄÌÑ∞ Îã§Ïö¥Î°úÎìúÌïòÏãúÍ≤†ÏäµÎãàÍπå?")
            .setPositiveButton("Îã§Ïö¥Î°úÎìú") { _, _ ->
                downloadFileFromConductor(fileName, fileServerUrl, targetPage)
            }
            .setNegativeButton("Ï∑®ÏÜå", null)
            .show()
    }
    
    private fun downloadFileFromConductor(fileName: String, serverUrl: String, targetPage: Int = 1) {
        val progressDialog = AlertDialog.Builder(this)
            .setTitle("Îã§Ïö¥Î°úÎìú Ï§ë...")
            .setMessage("$fileName\n0%")
            .setCancelable(false)
            .create()
        progressDialog.show()
        
        Log.d("PdfViewerActivity", "üéº ÌååÏùº Îã§Ïö¥Î°úÎìú ÏãúÏûë: $fileName (Î™©Ìëú ÌéòÏù¥ÏßÄ: $targetPage)")
        
        CoroutineScope(Dispatchers.IO).launch {
            try {
                val encodedFileName = java.net.URLEncoder.encode(fileName, "UTF-8")
                val downloadUrl = "$serverUrl/download/$encodedFileName"
                Log.d("PdfViewerActivity", "Downloading from: $downloadUrl")
                
                val url = java.net.URL(downloadUrl)
                val connection = url.openConnection()
                connection.connect()
                
                val fileLength = connection.contentLength
                val input = connection.getInputStream()
                val downloadPath = File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS), fileName)
                val output = java.io.FileOutputStream(downloadPath)
                
                val buffer = ByteArray(4096)
                var total: Long = 0
                var count: Int
                
                while (input.read(buffer).also { count = it } != -1) {
                    total += count
                    if (fileLength > 0) {
                        val progress = (total * 100 / fileLength).toInt()
                        withContext(Dispatchers.Main) {
                            progressDialog.setMessage("$fileName\n$progress%")
                        }
                    }
                    output.write(buffer, 0, count)
                }
                
                output.flush()
                output.close()
                input.close()
                
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@PdfViewerActivity, "Îã§Ïö¥Î°úÎìú ÏôÑÎ£å: $fileName", Toast.LENGTH_SHORT).show()
                    
                    // Refresh file list and load the downloaded file with target page
                    refreshFileListAndLoad(fileName, downloadPath.absolutePath, targetPage)
                }
                
            } catch (e: Exception) {
                Log.e("PdfViewerActivity", "Download failed", e)
                withContext(Dispatchers.Main) {
                    progressDialog.dismiss()
                    Toast.makeText(this@PdfViewerActivity, "Îã§Ïö¥Î°úÎìú Ïã§Ìå®: ${e.message}", Toast.LENGTH_LONG).show()
                }
            }
        }
    }
    
    private fun refreshFileListAndLoad(fileName: String, filePath: String, targetPage: Int = 1) {
        // Trigger media scanner to make file visible
        android.media.MediaScannerConnection.scanFile(
            this,
            arrayOf(filePath),
            arrayOf("application/pdf"),
            null
        )
        
        // Add to current file lists
        fileNameList = fileNameList.toMutableList().apply { add(fileName) }
        filePathList = filePathList.toMutableList().apply { add(filePath) }
        currentFileIndex = fileNameList.size - 1
        
        // Update current file info
        pdfFileName = fileName
        pdfFilePath = filePath
        
        // Notify that file list should be refreshed when returning to MainActivity
        val sharedPrefs = getSharedPreferences("pdf_viewer_prefs", MODE_PRIVATE)
        sharedPrefs.edit().putBoolean("refresh_file_list", true).apply()
        
        // Close current PDF if open
        try {
            currentPage?.close()
            currentPage = null
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "Error closing current page: ${e.message}")
        }
        
        try {
            pdfRenderer?.close()
            pdfRenderer = null
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "Error closing PDF renderer: ${e.message}")
        }
        
        Log.d("PdfViewerActivity", "üéº Îã§Ïö¥Î°úÎìúÎêú ÌååÏùº Î°úÎìú Ï§ë, Î™©Ìëú ÌéòÏù¥ÏßÄ: $targetPage")
        
        // Load the new file with target page
        loadPdfWithTargetPage(targetPage)
    }
    
    private fun loadPdfWithTargetPage(targetPage: Int) {
        CoroutineScope(Dispatchers.IO).launch {
            try {
                Log.d("PdfViewerActivity", "Loading PDF with target page: $pdfFilePath (target: $targetPage)")
                val file = File(pdfFilePath)
                
                if (!file.exists()) {
                    withContext(Dispatchers.Main) {
                        Toast.makeText(this@PdfViewerActivity, "ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: $pdfFileName", Toast.LENGTH_SHORT).show()
                        finish()
                    }
                    return@launch
                }
                
                val fileDescriptor = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)
                pdfRenderer = PdfRenderer(fileDescriptor)
                pageCount = pdfRenderer?.pageCount ?: 0
                
                withContext(Dispatchers.Main) {
                    if (pageCount > 0) {
                        // Initialize page cache
                        pageCache?.destroy()
                        
                        val firstPage = pdfRenderer!!.openPage(0)
                        val calculatedScale = calculateOptimalScale(firstPage.width, firstPage.height)
                        firstPage.close()
                        
                        pageCache = PageCache(pdfRenderer!!, screenWidth, screenHeight)
                        Log.d("PdfViewerActivity", "PageCache Ï¥àÍ∏∞Ìôî ÏôÑÎ£å for downloaded file")
                        
                        checkAndSetTwoPageMode {
                            // Recalculate scale based on the determined mode
                            val firstPage = pdfRenderer!!.openPage(0)
                            val finalScale = calculateOptimalScale(firstPage.width, firstPage.height, isTwoPageMode)
                            firstPage.close()
                            
                            Log.d("PdfViewerActivity", "Final scale for downloaded file, two-page mode $isTwoPageMode: $finalScale")
                            
                            // Clear cache and update settings to ensure clean state
                            pageCache?.clear()
                            pageCache?.updateSettings(isTwoPageMode, finalScale)
                            
                            // Navigate to target page
                            val targetIndex = (targetPage - 1).coerceIn(0, pageCount - 1)
                            showPage(targetIndex)
                            
                            Log.d("PdfViewerActivity", "üéº Îã§Ïö¥Î°úÎìúÎêú ÌååÏùº Î°úÎìú ÏôÑÎ£å, ÌéòÏù¥ÏßÄ $targetPage Î°ú Ïù¥Îèô")
                        }
                    } else {
                        Toast.makeText(this@PdfViewerActivity, "PDF ÌååÏùºÏóê ÌéòÏù¥ÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
                        finish()
                    }
                }
            } catch (e: Exception) {
                Log.e("PdfViewerActivity", "Error loading downloaded PDF", e)
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@PdfViewerActivity, "PDF Ïó¥Í∏∞ Ïã§Ìå®: ${e.message}", Toast.LENGTH_LONG).show()
                    finish()
                }
            }
        }
    }
    
    /**
     * PDF ÌëúÏãú ÏòµÏÖò Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÌëúÏãú (OK Î≤ÑÌäº Í∏∏Í≤å ÎàÑÎ•¥Í∏∞)
     */
    private fun showPdfDisplayOptions() {
        Log.d("PdfViewerActivity", "PDF ÌëúÏãú ÏòµÏÖò Îã§Ïù¥ÏñºÎ°úÍ∑∏ ÌëúÏãú")
        
        val options = arrayOf(
            "Îëê ÌéòÏù¥ÏßÄ Î™®Îìú Ï†ÑÌôò",
            "ÏúÑ/ÏïÑÎûò ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï",
            "Í∞ÄÏö¥Îç∞ Ïó¨Î∞± ÏÑ§Ï†ï",
            "Ï∑®ÏÜå"
        )
        
        AlertDialog.Builder(this)
            .setTitle("PDF ÌëúÏãú ÏòµÏÖò")
            .setItems(options) { dialog, which ->
                when (which) {
                    0 -> showTwoPageModeDialog { 
                        // Îëê ÌéòÏù¥ÏßÄ Î™®Îìú Î≥ÄÍ≤Ω ÏôÑÎ£å ÌõÑ ÌòÑÏû¨ ÌéòÏù¥ÏßÄ Îã§Ïãú Î†åÎçîÎßÅ
                        showPage(pageIndex)
                    }
                    1 -> showClippingDialog()
                    2 -> showPaddingDialog()
                    3 -> dialog.dismiss()
                }
            }
            .setNegativeButton("Ï∑®ÏÜå") { dialog, _ -> dialog.dismiss() }
            .show()
    }
    
    /**
     * PageCacheÏóê ÏÑ§Ï†ï ÏΩúÎ∞±ÏùÑ Îì±Î°ùÌïòÎäî Ìó¨Ìçº Ìï®Ïàò
     */
    private fun registerSettingsCallback() {
        pageCache?.setDisplaySettingsProvider { 
            Log.d("PdfViewerActivity", "ÏÑ§Ï†ï ÏΩúÎ∞± Ìò∏Ï∂ú: ÏúÑ ${(currentTopClipping * 100).toInt()}%, ÏïÑÎûò ${(currentBottomClipping * 100).toInt()}%, Ïó¨Î∞± ${(currentCenterPadding * 100).toInt()}%")
            Triple(currentTopClipping, currentBottomClipping, currentCenterPadding) 
        }
    }
    
    /**
     * ÌòÑÏû¨ ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ïÏóê Ìï¥ÎãπÌïòÎäî ÏÑ†ÌÉù Ìï≠Î™© Ï∞æÍ∏∞ (deprecated - Ïä¨ÎùºÏù¥Îçî UIÎ°ú ÎåÄÏ≤¥Îê®)
     */
    @Deprecated("No longer needed with slider UI")
    private fun getCurrentClippingSelection(): Int {
        return when {
            currentTopClipping == 0f && currentBottomClipping == 0f -> 0 // ÌÅ¥Î¶¨Ìïë ÏóÜÏùå
            currentTopClipping == 0.05f && currentBottomClipping == 0f -> 1 // ÏúÑ 5%
            currentTopClipping == 0.10f && currentBottomClipping == 0f -> 2 // ÏúÑ 10%
            currentTopClipping == 0.15f && currentBottomClipping == 0f -> 3 // ÏúÑ 15%
            currentTopClipping == 0f && currentBottomClipping == 0.05f -> 4 // ÏïÑÎûò 5%
            currentTopClipping == 0f && currentBottomClipping == 0.10f -> 5 // ÏïÑÎûò 10%
            currentTopClipping == 0f && currentBottomClipping == 0.15f -> 6 // ÏïÑÎûò 15%
            currentTopClipping == 0.05f && currentBottomClipping == 0.05f -> 7 // ÏúÑ/ÏïÑÎûò Í∞Å 5%
            currentTopClipping == 0.10f && currentBottomClipping == 0.10f -> 8 // ÏúÑ/ÏïÑÎûò Í∞Å 10%
            else -> -1 // ÏÇ¨Ïö©Ïûê Ï†ïÏùò
        }
    }
    
    /**
     * ÏúÑ/ÏïÑÎûò ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï Îã§Ïù¥ÏñºÎ°úÍ∑∏
     */
    private fun showClippingDialog() {
        // Ïª§Ïä§ÌÖÄ Î†àÏù¥ÏïÑÏõÉ ÏÉùÏÑ±
        val dialogView = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            setPadding(50, 30, 50, 30)
        }
        
        // ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë Î†àÏù¥Î∏î
        val topLabel = android.widget.TextView(this).apply {
            text = "ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë: ${(currentTopClipping * 100).toInt()}%"
            textSize = 16f
            setPadding(0, 0, 0, 10)
        }
        dialogView.addView(topLabel)
        
        // ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë Ïä¨ÎùºÏù¥Îçî (0-30%)
        val topSeekBar = android.widget.SeekBar(this).apply {
            max = 15  // 0-15%
            progress = (currentTopClipping * 100).toInt()
            setPadding(0, 0, 0, 30)
        }
        dialogView.addView(topSeekBar)
        
        // ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë Î†àÏù¥Î∏î
        val bottomLabel = android.widget.TextView(this).apply {
            text = "ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë: ${(currentBottomClipping * 100).toInt()}%"
            textSize = 16f
            setPadding(0, 0, 0, 10)
        }
        dialogView.addView(bottomLabel)
        
        // ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë Ïä¨ÎùºÏù¥Îçî (0-30%)
        val bottomSeekBar = android.widget.SeekBar(this).apply {
            max = 15  // 0-15%
            progress = (currentBottomClipping * 100).toInt()
            setPadding(0, 0, 0, 20)
        }
        dialogView.addView(bottomSeekBar)
        
        // Îπ†Î•∏ ÏÑ§Ï†ï Î≤ÑÌäºÎì§
        val quickButtonsLayout = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.HORIZONTAL
            gravity = android.view.Gravity.CENTER
            setPadding(0, 20, 0, 10)
        }
        
        val resetButton = android.widget.Button(this).apply {
            text = "Ï¥àÍ∏∞Ìôî"
            setOnClickListener {
                topSeekBar.progress = 0
                bottomSeekBar.progress = 0
                setupPreview(topSeekBar)
            }
        }
        quickButtonsLayout.addView(resetButton)
        
        val bothButton = android.widget.Button(this).apply {
            text = "ÏúÑ/ÏïÑÎûò 5%"
            setOnClickListener {
                topSeekBar.progress = 5
                bottomSeekBar.progress = 5
                setupPreview(topSeekBar)
            }
        }
        quickButtonsLayout.addView(bothButton)
        
        dialogView.addView(quickButtonsLayout)
        
        // ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖçÏä§Ìä∏
        val previewLabel = android.widget.TextView(this).apply {
            text = "Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞Í∞Ä Ï†ÅÏö©Îê©ÎãàÎã§"
            textSize = 12f
            setTextColor(android.graphics.Color.GRAY)
            gravity = android.view.Gravity.CENTER
            setPadding(0, 10, 0, 0)
        }
        dialogView.addView(previewLabel)
        
        // Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞Î•º ÏúÑÌïú Î≥ÄÏàò
        var previewHandler: android.os.Handler? = null
        var previewRunnable: Runnable? = null
        
        // ÏõêÎûò ÏÑ§Ï†ï Ï†ÄÏû•
        val originalTop = currentTopClipping
        val originalBottom = currentBottomClipping
        
        val applyPreview = {
            val topPercent = topSeekBar.progress / 100f
            val bottomPercent = bottomSeekBar.progress / 100f
            
            // ÏûÑÏãúÎ°ú ÏÑ§Ï†ï Ï†ÅÏö© (Ï†ÄÏû•ÌïòÏßÄ ÏïäÏùå)
            currentTopClipping = topPercent
            currentBottomClipping = bottomPercent
            
            // ÌéòÏù¥ÏßÄ Îã§Ïãú Î†åÎçîÎßÅ
            forceDirectRendering = true
            showPage(pageIndex)
            
            Log.d("PdfViewerActivity", "ÎØ∏Î¶¨Î≥¥Í∏∞ Ï†ÅÏö©: ÏúÑ ${(topPercent * 100).toInt()}%, ÏïÑÎûò ${(bottomPercent * 100).toInt()}%")
        }
        
        val setupPreview = { _: android.widget.SeekBar ->
            previewRunnable?.let { previewHandler?.removeCallbacks(it) }
            previewRunnable = Runnable { applyPreview() }
            previewHandler = android.os.Handler(android.os.Looper.getMainLooper())
            previewHandler?.postDelayed(previewRunnable!!, 200) // 200ms ÎîúÎ†àÏù¥
        }
        
        // Ïä¨ÎùºÏù¥ÎçîÏóê Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞ Ïó∞Í≤∞
        topSeekBar.setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                topLabel.text = "ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë: ${progress}%"
                if (fromUser) setupPreview(seekBar!!)
            }
            override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
            override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {}
        })
        
        bottomSeekBar.setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                bottomLabel.text = "ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë: ${progress}%"
                if (fromUser) setupPreview(seekBar!!)
            }
            override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
            override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {}
        })
        
        AlertDialog.Builder(this)
            .setTitle("ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï")
            .setView(dialogView)
            .setPositiveButton("Ï†ÅÏö©") { _, _ ->
                val topPercent = topSeekBar.progress / 100f
                val bottomPercent = bottomSeekBar.progress / 100f
                
                saveClippingSettings(topPercent, bottomPercent)
                Toast.makeText(this, "ÏúÑ ${(topPercent * 100).toInt()}%, ÏïÑÎûò ${(bottomPercent * 100).toInt()}% ÌÅ¥Î¶¨ÌïëÏùÑ Ï†ÅÏö©ÌñàÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
                
                Log.d("PdfViewerActivity", "=== ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï Ï†ÅÏö© ===")
                Log.d("PdfViewerActivity", "ÏúÑ: ${(topPercent * 100).toInt()}%, ÏïÑÎûò: ${(bottomPercent * 100).toInt()}%")
                
                registerSettingsCallback()
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .setNegativeButton("Ï∑®ÏÜå") { _, _ ->
                // ÏõêÎûò ÏÑ§Ï†ïÏúºÎ°ú Î≥µÏõê
                currentTopClipping = originalTop
                currentBottomClipping = originalBottom
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .setOnCancelListener {
                // Ï∑®ÏÜå ÏãúÏóêÎèÑ ÏõêÎûò ÏÑ§Ï†ïÏúºÎ°ú Î≥µÏõê
                currentTopClipping = originalTop
                currentBottomClipping = originalBottom
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .show()
    }
    
    /**
     * ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï Îã§Ïù¥ÏñºÎ°úÍ∑∏ (deprecated - showClippingDialogÎ°ú ÌÜµÌï©Îê®)
     */
    @Deprecated("Use showClippingDialog instead", ReplaceWith("showClippingDialog()"))
    private fun showCustomClippingDialog() {
        // Ïª§Ïä§ÌÖÄ Î†àÏù¥ÏïÑÏõÉ ÏÉùÏÑ±
        val dialogView = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            setPadding(50, 30, 50, 30)
        }
        
        // ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë Î†àÏù¥Î∏î
        val topLabel = android.widget.TextView(this).apply {
            text = "ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë: ${(currentTopClipping * 100).toInt()}%"
            textSize = 16f
            setPadding(0, 0, 0, 10)
        }
        dialogView.addView(topLabel)
        
        // ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë Ïä¨ÎùºÏù¥Îçî (0-30%)
        val topSeekBar = android.widget.SeekBar(this).apply {
            max = 15  // 0-15%
            progress = (currentTopClipping * 100).toInt()
            setPadding(0, 0, 0, 30)
            setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
                override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                    topLabel.text = "ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë: ${progress}%"
                }
                override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
                override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {}
            })
        }
        dialogView.addView(topSeekBar)
        
        // ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë Î†àÏù¥Î∏î
        val bottomLabel = android.widget.TextView(this).apply {
            text = "ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë: ${(currentBottomClipping * 100).toInt()}%"
            textSize = 16f
            setPadding(0, 0, 0, 10)
        }
        dialogView.addView(bottomLabel)
        
        // ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë Ïä¨ÎùºÏù¥Îçî (0-30%)
        val bottomSeekBar = android.widget.SeekBar(this).apply {
            max = 15  // 0-15%
            progress = (currentBottomClipping * 100).toInt()
            setPadding(0, 0, 0, 20)
            setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
                override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                    bottomLabel.text = "ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë: ${progress}%"
                }
                override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
                override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {}
            })
        }
        dialogView.addView(bottomSeekBar)
        
        // ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖçÏä§Ìä∏
        val previewLabel = android.widget.TextView(this).apply {
            text = "Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞Í∞Ä Ï†ÅÏö©Îê©ÎãàÎã§"
            textSize = 12f
            setTextColor(android.graphics.Color.GRAY)
            gravity = android.view.Gravity.CENTER
        }
        dialogView.addView(previewLabel)
        
        // Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞Î•º ÏúÑÌïú Î≥ÄÏàò
        var previewHandler: android.os.Handler? = null
        var previewRunnable: Runnable? = null
        
        val applyPreview = {
            val topPercent = topSeekBar.progress / 100f
            val bottomPercent = bottomSeekBar.progress / 100f
            
            // ÏûÑÏãúÎ°ú ÏÑ§Ï†ï Ï†ÅÏö© (Ï†ÄÏû•ÌïòÏßÄ ÏïäÏùå)
            val oldTop = currentTopClipping
            val oldBottom = currentBottomClipping
            currentTopClipping = topPercent
            currentBottomClipping = bottomPercent
            
            // ÌéòÏù¥ÏßÄ Îã§Ïãú Î†åÎçîÎßÅ
            forceDirectRendering = true
            showPage(pageIndex)
            
            Log.d("PdfViewerActivity", "ÎØ∏Î¶¨Î≥¥Í∏∞ Ï†ÅÏö©: ÏúÑ ${(topPercent * 100).toInt()}%, ÏïÑÎûò ${(bottomPercent * 100).toInt()}%")
        }
        
        val setupPreview = { _: android.widget.SeekBar ->
            previewRunnable?.let { previewHandler?.removeCallbacks(it) }
            previewRunnable = Runnable { applyPreview() }
            previewHandler = android.os.Handler(android.os.Looper.getMainLooper())
            previewHandler?.postDelayed(previewRunnable!!, 200) // 200ms ÎîúÎ†àÏù¥
        }
        
        // Ïä¨ÎùºÏù¥ÎçîÏóê Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞ Ïó∞Í≤∞
        topSeekBar.setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                topLabel.text = "ÏúÑÏ™Ω ÌÅ¥Î¶¨Ìïë: ${progress}%"
                if (fromUser) setupPreview(seekBar!!)
            }
            override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
            override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {}
        })
        
        bottomSeekBar.setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                bottomLabel.text = "ÏïÑÎûòÏ™Ω ÌÅ¥Î¶¨Ìïë: ${progress}%"
                if (fromUser) setupPreview(seekBar!!)
            }
            override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
            override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {}
        })
        
        AlertDialog.Builder(this)
            .setTitle("ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï")
            .setView(dialogView)
            .setPositiveButton("Ï†ÅÏö©") { _, _ ->
                val topPercent = topSeekBar.progress / 100f
                val bottomPercent = bottomSeekBar.progress / 100f
                
                saveClippingSettings(topPercent, bottomPercent)
                Toast.makeText(this, "ÏúÑ ${(topPercent * 100).toInt()}%, ÏïÑÎûò ${(bottomPercent * 100).toInt()}% ÌÅ¥Î¶¨ÌïëÏùÑ Ï†ÅÏö©ÌñàÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
                
                Log.d("PdfViewerActivity", "=== ÏÇ¨Ïö©Ïûê Ï†ïÏùò ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï Ï†ÅÏö© ===")
                Log.d("PdfViewerActivity", "ÏúÑ: ${(topPercent * 100).toInt()}%, ÏïÑÎûò: ${(bottomPercent * 100).toInt()}%")
                
                registerSettingsCallback()
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .setNegativeButton("Ï∑®ÏÜå") { _, _ ->
                // ÏõêÎûò ÏÑ§Ï†ïÏúºÎ°ú Î≥µÏõê
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .setOnCancelListener {
                // Ï∑®ÏÜå ÏãúÏóêÎèÑ ÏõêÎûò ÏÑ§Ï†ïÏúºÎ°ú Î≥µÏõê
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .show()
    }
    
    /**
     * ÌòÑÏû¨ Ïó¨Î∞± ÏÑ§Ï†ïÏóê Ìï¥ÎãπÌïòÎäî ÏÑ†ÌÉù Ìï≠Î™© Ï∞æÍ∏∞
     */
    @Deprecated("No longer needed with slider UI")
    private fun getCurrentPaddingSelection(): Int {
        return when {
            currentCenterPadding == 0f -> 0    // Ïó¨Î∞± ÏóÜÏùå
            currentCenterPadding == 0.05f -> 1   // 5%
            currentCenterPadding == 0.10f -> 2   // 10%
            else -> -1 // ÏÇ¨Ïö©Ïûê Ï†ïÏùò
        }
    }
    
    /**
     * Í∞ÄÏö¥Îç∞ Ïó¨Î∞± ÏÑ§Ï†ï Îã§Ïù¥ÏñºÎ°úÍ∑∏
     */
    private fun showPaddingDialog() {
        // Ïª§Ïä§ÌÖÄ Î†àÏù¥ÏïÑÏõÉ ÏÉùÏÑ±
        val dialogView = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.VERTICAL
            setPadding(50, 30, 50, 30)
        }
        
        // Í∞ÄÏö¥Îç∞ Ïó¨Î∞± Î†àÏù¥Î∏î
        val paddingLabel = android.widget.TextView(this).apply {
            text = "Í∞ÄÏö¥Îç∞ Ïó¨Î∞±: ${(currentCenterPadding * 100).toInt()}%"
            textSize = 16f
            setPadding(0, 0, 0, 10)
        }
        dialogView.addView(paddingLabel)
        
        // Í∞ÄÏö¥Îç∞ Ïó¨Î∞± Ïä¨ÎùºÏù¥Îçî (0-15%)
        val paddingSeekBar = android.widget.SeekBar(this).apply {
            max = 15  // 0-15%
            progress = (currentCenterPadding * 100).toInt()
            setPadding(0, 0, 0, 20)
        }
        dialogView.addView(paddingSeekBar)
        
        // Îπ†Î•∏ ÏÑ§Ï†ï Î≤ÑÌäºÎì§
        val quickButtonsLayout = android.widget.LinearLayout(this).apply {
            orientation = android.widget.LinearLayout.HORIZONTAL
            gravity = android.view.Gravity.CENTER
            setPadding(0, 20, 0, 10)
        }
        
        val resetButton = android.widget.Button(this).apply {
            text = "Ïó¨Î∞± ÏóÜÏùå"
            setOnClickListener {
                paddingSeekBar.progress = 0
                setupPreview(paddingSeekBar)
            }
        }
        quickButtonsLayout.addView(resetButton)
        
        val preset5Button = android.widget.Button(this).apply {
            text = "5%"
            setOnClickListener {
                paddingSeekBar.progress = 5
                setupPreview(paddingSeekBar)
            }
        }
        quickButtonsLayout.addView(preset5Button)
        
        val preset10Button = android.widget.Button(this).apply {
            text = "10%"
            setOnClickListener {
                paddingSeekBar.progress = 10
                setupPreview(paddingSeekBar)
            }
        }
        quickButtonsLayout.addView(preset10Button)
        
        dialogView.addView(quickButtonsLayout)
        
        // ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖçÏä§Ìä∏
        val previewLabel = android.widget.TextView(this).apply {
            text = "Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞Í∞Ä Ï†ÅÏö©Îê©ÎãàÎã§"
            textSize = 12f
            setTextColor(android.graphics.Color.GRAY)
            gravity = android.view.Gravity.CENTER
            setPadding(0, 10, 0, 0)
        }
        dialogView.addView(previewLabel)
        
        // Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞Î•º ÏúÑÌïú Î≥ÄÏàò
        var previewHandler: android.os.Handler? = null
        var previewRunnable: Runnable? = null
        
        // ÏõêÎûò ÏÑ§Ï†ï Ï†ÄÏû•
        val originalPadding = currentCenterPadding
        
        val applyPreview = {
            val paddingPercent = paddingSeekBar.progress / 100f
            
            // ÏûÑÏãúÎ°ú ÏÑ§Ï†ï Ï†ÅÏö© (Ï†ÄÏû•ÌïòÏßÄ ÏïäÏùå)
            currentCenterPadding = paddingPercent
            
            // ÌéòÏù¥ÏßÄ Îã§Ïãú Î†åÎçîÎßÅ
            forceDirectRendering = true
            showPage(pageIndex)
            
            Log.d("PdfViewerActivity", "ÎØ∏Î¶¨Î≥¥Í∏∞ Ï†ÅÏö©: Í∞ÄÏö¥Îç∞ Ïó¨Î∞± ${(paddingPercent * 100).toInt()}%")
        }
        
        val setupPreview = { _: android.widget.SeekBar ->
            previewRunnable?.let { previewHandler?.removeCallbacks(it) }
            previewRunnable = Runnable { applyPreview() }
            previewHandler = android.os.Handler(android.os.Looper.getMainLooper())
            previewHandler?.postDelayed(previewRunnable!!, 200) // 200ms ÎîúÎ†àÏù¥
        }
        
        // Ïä¨ÎùºÏù¥ÎçîÏóê Ïã§ÏãúÍ∞Ñ ÎØ∏Î¶¨Î≥¥Í∏∞ Ïó∞Í≤∞
        paddingSeekBar.setOnSeekBarChangeListener(object : android.widget.SeekBar.OnSeekBarChangeListener {
            override fun onProgressChanged(seekBar: android.widget.SeekBar?, progress: Int, fromUser: Boolean) {
                paddingLabel.text = "Í∞ÄÏö¥Îç∞ Ïó¨Î∞±: ${progress}%"
                if (fromUser) setupPreview(seekBar!!)
            }
            override fun onStartTrackingTouch(seekBar: android.widget.SeekBar?) {}
            override fun onStopTrackingTouch(seekBar: android.widget.SeekBar?) {}
        })
        
        AlertDialog.Builder(this)
            .setTitle("Í∞ÄÏö¥Îç∞ Ïó¨Î∞± ÏÑ§Ï†ï")
            .setView(dialogView)
            .setPositiveButton("Ï†ÅÏö©") { _, _ ->
                val paddingPercent = paddingSeekBar.progress / 100f
                
                savePaddingSettings(paddingPercent)
                Toast.makeText(this, "Í∞ÄÏö¥Îç∞ Ïó¨Î∞± ${(paddingPercent * 100).toInt()}%Î•º Ï†ÅÏö©ÌñàÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
                
                Log.d("PdfViewerActivity", "=== Í∞ÄÏö¥Îç∞ Ïó¨Î∞± ÏÑ§Ï†ï Ï†ÅÏö© ===")
                Log.d("PdfViewerActivity", "Ïó¨Î∞±: ${(paddingPercent * 100).toInt()}%")
                
                registerSettingsCallback()
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .setNegativeButton("Ï∑®ÏÜå") { _, _ ->
                // ÏõêÎûò ÏÑ§Ï†ïÏúºÎ°ú Î≥µÏõê
                currentCenterPadding = originalPadding
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .setOnCancelListener {
                // Ï∑®ÏÜå ÏãúÏóêÎèÑ ÏõêÎûò ÏÑ§Ï†ïÏúºÎ°ú Î≥µÏõê
                currentCenterPadding = originalPadding
                forceDirectRendering = true
                showPage(pageIndex)
            }
            .show()
    }
    
    /**
     * ÌÅ¥Î¶¨ÌïëÍ≥º Ïó¨Î∞± ÏÑ§Ï†ïÏùÑ ÎπÑÌä∏ÎßµÏóê Ï†ÅÏö©
     */
    private fun applyDisplaySettings(originalBitmap: Bitmap, isTwoPageMode: Boolean): Bitmap {
        Log.d("PdfViewerActivity", "=== applyDisplaySettings Ìò∏Ï∂úÎê® ===")
        Log.d("PdfViewerActivity", "ÌòÑÏû¨ ÏÑ§Ï†ï: ÏúÑ ÌÅ¥Î¶¨Ìïë ${currentTopClipping * 100}%, ÏïÑÎûò ÌÅ¥Î¶¨Ìïë ${currentBottomClipping * 100}%, Ïó¨Î∞± ${currentCenterPadding}px")
        Log.d("PdfViewerActivity", "isTwoPageMode: $isTwoPageMode, ÏõêÎ≥∏ ÌÅ¨Í∏∞: ${originalBitmap.width}x${originalBitmap.height}")
        
        val hasClipping = currentTopClipping > 0f || currentBottomClipping > 0f
        val hasPadding = currentCenterPadding > 0 && isTwoPageMode
        
        Log.d("PdfViewerActivity", "hasClipping: $hasClipping, hasPadding: $hasPadding")
        
        if (!hasClipping && !hasPadding) {
            Log.d("PdfViewerActivity", "ÏÑ§Ï†ïÏù¥ ÏóÜÏñ¥ÏÑú ÏõêÎ≥∏ Î∞òÌôò")
            return originalBitmap
        }
        
        Log.d("PdfViewerActivity", "ÌëúÏãú ÏÑ§Ï†ï Ï†ÅÏö© Ï§ë: ÏúÑ ÌÅ¥Î¶¨Ìïë ${currentTopClipping * 100}%, ÏïÑÎûò ÌÅ¥Î¶¨Ìïë ${currentBottomClipping * 100}%, Ïó¨Î∞± ${currentCenterPadding}px")
        
        val originalWidth = originalBitmap.width
        val originalHeight = originalBitmap.height
        
        // ÌÅ¥Î¶¨Ìïë Í≥ÑÏÇ∞
        val topClipPixels = (originalHeight * currentTopClipping).toInt()
        val bottomClipPixels = (originalHeight * currentBottomClipping).toInt()
        val clippedHeight = originalHeight - topClipPixels - bottomClipPixels
        
        // Ïó¨Î∞± Í≥ÑÏÇ∞ (Îëê ÌéòÏù¥ÏßÄ Î™®ÎìúÏóêÏÑúÎßå)
        val paddingWidth = if (isTwoPageMode && currentCenterPadding > 0) {
            (originalWidth * currentCenterPadding).toInt()
        } else {
            0
        }
        val finalWidth = originalWidth + paddingWidth
        val finalHeight = clippedHeight
        
        if (finalWidth <= 0 || finalHeight <= 0) {
            Log.w("PdfViewerActivity", "ÌÅ¥Î¶¨Ìïë Í≤∞Í≥ºÍ∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏùå: ${finalWidth}x${finalHeight}")
            return originalBitmap
        }
        
        // ÏÉà ÎπÑÌä∏Îßµ ÏÉùÏÑ±
        val resultBitmap = Bitmap.createBitmap(finalWidth, finalHeight, Bitmap.Config.ARGB_8888)
        val canvas = Canvas(resultBitmap)
        canvas.drawColor(android.graphics.Color.WHITE)
        
        if (isTwoPageMode) {
            // Îëê ÌéòÏù¥ÏßÄ Î™®ÎìúÏóêÏÑúÎäî Ïó¨Î∞±Ïù¥ Ïù¥ÎØ∏ Ï†ÅÏö©ÎêòÏóàÏúºÎØÄÎ°ú ÌÅ¥Î¶¨ÌïëÎßå Ï†ÅÏö©
            // Ïó¨Î∞±ÏùÑ Í≥†Î†§Ìïú ÏµúÏ¢Ö Ìè≠ Í≥ÑÏÇ∞ (Ïó¨Î∞±Ïù¥ Ïù¥ÎØ∏ Ï†ÅÏö©Îêú ÏÉÅÌÉú)
            val actualPaddingWidth = if (currentCenterPadding > 0) {
                (originalWidth * currentCenterPadding).toInt()
            } else {
                0
            }
            val leftPageWidth = (originalWidth - actualPaddingWidth) / 2
            val rightPageStartX = leftPageWidth + actualPaddingWidth
            
            Log.d("PdfViewerActivity", "Îëê ÌéòÏù¥ÏßÄ ÌÅ¥Î¶¨Ìïë: ÏõêÎ≥∏ Ìè≠=${originalWidth}, Ïó¨Î∞±=${actualPaddingWidth}, ÏôºÏ™Ω ÌéòÏù¥ÏßÄ Ìè≠=${leftPageWidth}")
            
            // ÏôºÏ™Ω ÌéòÏù¥ÏßÄ (ÌÅ¥Î¶¨ÌïëÎêú Î∂ÄÎ∂Ñ)
            val leftSrcRect = android.graphics.Rect(0, topClipPixels, leftPageWidth, originalHeight - bottomClipPixels)
            val leftDstRect = android.graphics.Rect(0, 0, leftPageWidth, clippedHeight)
            canvas.drawBitmap(originalBitmap, leftSrcRect, leftDstRect, null)
            
            // Í∞ÄÏö¥Îç∞ Ïó¨Î∞± Î∂ÄÎ∂ÑÏùÄ Ìù∞ÏÉâÏúºÎ°ú Ïú†ÏßÄ (Ïù¥ÎØ∏ drawColorÎ°ú Ï≤òÎ¶¨Îê®)
            
            // Ïò§Î•∏Ï™Ω ÌéòÏù¥ÏßÄ (ÌÅ¥Î¶¨ÌïëÎêú Î∂ÄÎ∂Ñ)
            val rightSrcRect = android.graphics.Rect(rightPageStartX, topClipPixels, originalWidth, originalHeight - bottomClipPixels)
            val rightDstRect = android.graphics.Rect(rightPageStartX, 0, finalWidth, clippedHeight)
            canvas.drawBitmap(originalBitmap, rightSrcRect, rightDstRect, null)
            
        } else {
            // Îã®Ïùº ÌéòÏù¥ÏßÄ Î™®ÎìúÏóêÏÑú ÌÅ¥Î¶¨ÌïëÎßå Ï†ÅÏö©
            val srcRect = android.graphics.Rect(0, topClipPixels, originalWidth, originalHeight - bottomClipPixels)
            val dstRect = android.graphics.Rect(0, 0, originalWidth, clippedHeight)
            canvas.drawBitmap(originalBitmap, srcRect, dstRect, null)
        }
        
        // ÏõêÎ≥∏ ÎπÑÌä∏ÎßµÏùÑ Ïû¨ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùÑ ÎïåÎßå Ìï¥Ï†ú
        if (resultBitmap != originalBitmap) {
            originalBitmap.recycle()
        }
        
        Log.d("PdfViewerActivity", "ÌëúÏãú ÏÑ§Ï†ï Ï†ÅÏö© ÏôÑÎ£å: ${originalWidth}x${originalHeight} ‚Üí ${finalWidth}x${finalHeight}")
        return resultBitmap
    }
    
    /**
     * Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌëúÏãú ÏÑ§Ï†ï Î°úÎìú (ÎèôÍ∏∞)
     */
    private suspend fun loadDisplaySettingsSync() = withContext(Dispatchers.IO) {
        Log.d("PdfViewerActivity", "=== loadDisplaySettingsSync ÏãúÏûë ===")
        Log.d("PdfViewerActivity", "currentPdfFileId: $currentPdfFileId")
        
        currentPdfFileId?.let { fileId ->
            try {
                val prefs = musicRepository.getUserPreference(fileId)
                Log.d("PdfViewerActivity", "DBÏóêÏÑú Ï°∞ÌöåÎêú ÏÑ§Ï†ï: $prefs")
                
                if (prefs != null) {
                    withContext(Dispatchers.Main) {
                        currentTopClipping = prefs.topClippingPercent
                        currentBottomClipping = prefs.bottomClippingPercent
                        currentCenterPadding = prefs.centerPadding
                        Log.d("PdfViewerActivity", "=== Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å ===")
                        Log.d("PdfViewerActivity", "Î°úÎìúÎêú ÏÑ§Ï†ï: ÏúÑ ÌÅ¥Î¶¨Ìïë ${currentTopClipping * 100}%, ÏïÑÎûò ÌÅ¥Î¶¨Ìïë ${currentBottomClipping * 100}%, Ïó¨Î∞± ${currentCenterPadding}px")
                    }
                } else {
                    // Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
                    withContext(Dispatchers.Main) {
                        currentTopClipping = 0f
                        currentBottomClipping = 0f
                        currentCenterPadding = 0f
                    }
                    Log.d("PdfViewerActivity", "ÌëúÏãú ÏÑ§Ï†ï ÏóÜÏùå, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                }
            } catch (e: Exception) {
                Log.e("PdfViewerActivity", "ÌëúÏãú ÏÑ§Ï†ï Î°úÎìú Ïã§Ìå®", e)
                // Í∏∞Î≥∏Í∞íÏúºÎ°ú Ìè¥Î∞±
                withContext(Dispatchers.Main) {
                    currentTopClipping = 0f
                    currentBottomClipping = 0f
                    currentCenterPadding = 0f
                }
            }
        } ?: run {
            Log.w("PdfViewerActivity", "currentPdfFileIdÍ∞Ä nullÏù¥Ïñ¥ÏÑú ÏÑ§Ï†ïÏùÑ Î°úÎìúÌï† Ïàò ÏóÜÏäµÎãàÎã§")
        }
    }
    
    /**
     * Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ÌëúÏãú ÏÑ§Ï†ï Î°úÎìú (ÎπÑÎèôÍ∏∞)
     */
    private fun loadDisplaySettings() {
        currentPdfFileId?.let { fileId ->
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val prefs = musicRepository.getUserPreference(fileId)
                    if (prefs != null) {
                        currentTopClipping = prefs.topClippingPercent
                        currentBottomClipping = prefs.bottomClippingPercent
                        currentCenterPadding = prefs.centerPadding
                        Log.d("PdfViewerActivity", "ÌëúÏãú ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å: ÏúÑ ÌÅ¥Î¶¨Ìïë ${currentTopClipping * 100}%, ÏïÑÎûò ÌÅ¥Î¶¨Ìïë ${currentBottomClipping * 100}%, Ïó¨Î∞± ${currentCenterPadding}px")
                    } else {
                        // Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
                        currentTopClipping = 0f
                        currentBottomClipping = 0f
                        currentCenterPadding = 0f
                        Log.d("PdfViewerActivity", "ÌëúÏãú ÏÑ§Ï†ï ÏóÜÏùå, Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©")
                    }
                } catch (e: Exception) {
                    Log.e("PdfViewerActivity", "ÌëúÏãú ÏÑ§Ï†ï Î°úÎìú Ïã§Ìå®", e)
                    // Í∏∞Î≥∏Í∞íÏúºÎ°ú Ìè¥Î∞±
                    currentTopClipping = 0f
                    currentBottomClipping = 0f
                    currentCenterPadding = 0f
                }
            }
        }
    }
    
    /**
     * ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ïÏùÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
     */
    private fun saveClippingSettings(topPercent: Float, bottomPercent: Float) {
        currentPdfFileId?.let { fileId ->
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val currentPrefs = musicRepository.getUserPreference(fileId)
                    val updatedPrefs = if (currentPrefs != null) {
                        currentPrefs.copy(
                            topClippingPercent = topPercent,
                            bottomClippingPercent = bottomPercent,
                            updatedAt = System.currentTimeMillis()
                        )
                    } else {
                        // Í∏∞Î≥∏ ÏÑ§Ï†ïÏúºÎ°ú ÏÉàÎ°ú ÏÉùÏÑ±
                        UserPreference(
                            pdfFileId = fileId,
                            displayMode = DisplayMode.AUTO,
                            topClippingPercent = topPercent,
                            bottomClippingPercent = bottomPercent
                        )
                    }
                    musicRepository.insertUserPreference(updatedPrefs)
                    
                    // Update current settings
                    withContext(Dispatchers.Main) {
                        Log.d("PdfViewerActivity", "=== ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏ ===")
                        Log.d("PdfViewerActivity", "Ïù¥Ï†Ñ: ÏúÑ ${currentTopClipping * 100}%, ÏïÑÎûò ${currentBottomClipping * 100}%")
                        currentTopClipping = topPercent
                        currentBottomClipping = bottomPercent
                        Log.d("PdfViewerActivity", "Ïù¥ÌõÑ: ÏúÑ ${currentTopClipping * 100}%, ÏïÑÎûò ${currentBottomClipping * 100}%")
                    }
                    
                    Log.d("PdfViewerActivity", "ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï Ï†ÄÏû• ÏôÑÎ£å: ÏúÑ ${topPercent * 100}%, ÏïÑÎûò ${bottomPercent * 100}%")
                } catch (e: Exception) {
                    Log.e("PdfViewerActivity", "ÌÅ¥Î¶¨Ìïë ÏÑ§Ï†ï Ï†ÄÏû• Ïã§Ìå®", e)
                }
            }
        }
    }
    
    /**
     * Ïó¨Î∞± ÏÑ§Ï†ïÏùÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
     */
    private fun savePaddingSettings(padding: Float) {
        currentPdfFileId?.let { fileId ->
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val currentPrefs = musicRepository.getUserPreference(fileId)
                    val updatedPrefs = if (currentPrefs != null) {
                        currentPrefs.copy(
                            centerPadding = padding,
                            updatedAt = System.currentTimeMillis()
                        )
                    } else {
                        // Í∏∞Î≥∏ ÏÑ§Ï†ïÏúºÎ°ú ÏÉàÎ°ú ÏÉùÏÑ±
                        UserPreference(
                            pdfFileId = fileId,
                            displayMode = DisplayMode.AUTO,
                            centerPadding = padding
                        )
                    }
                    musicRepository.insertUserPreference(updatedPrefs)
                    
                    // Update current settings
                    withContext(Dispatchers.Main) {
                        Log.d("PdfViewerActivity", "=== Ïó¨Î∞± ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏ ===")
                        Log.d("PdfViewerActivity", "Ïù¥Ï†Ñ: ${(currentCenterPadding * 100).toInt()}%")
                        currentCenterPadding = padding
                        Log.d("PdfViewerActivity", "Ïù¥ÌõÑ: ${(currentCenterPadding * 100).toInt()}%")
                    }
                    
                    Log.d("PdfViewerActivity", "Ïó¨Î∞± ÏÑ§Ï†ï Ï†ÄÏû• ÏôÑÎ£å: ${(padding * 100).toInt()}%")
                } catch (e: Exception) {
                    Log.e("PdfViewerActivity", "Ïó¨Î∞± ÏÑ§Ï†ï Ï†ÄÏû• Ïã§Ìå®", e)
                }
            }
        }
    }

    override fun onPause() {
        super.onPause()
        
        // Clear collaboration callbacks when PdfViewerActivity goes to background
        // This allows MainActivity to properly register its callbacks when it resumes
        Log.d("PdfViewerActivity", "onPause - ÌòëÏóÖ ÏΩúÎ∞± Ï†ïÎ¶¨")
    }
    
    override fun onDestroy() {
        super.onDestroy()
        
        // Clean up long press handler
        longPressHandler.removeCallbacks(longPressRunnable)
        
        // Clean up collaboration resources
        // Note: Ï†ÑÏó≠ Îß§ÎãàÏ†ÄÍ∞Ä Í¥ÄÎ¶¨ÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑú ÏÑúÎ≤ÑÎ•º Ï§ëÏßÄÌïòÏßÄ ÏïäÏùå
        // Note: Ï†ÑÏó≠ Îß§ÎãàÏ†ÄÍ∞Ä Í¥ÄÎ¶¨ÌïòÎØÄÎ°ú Ïó¨Í∏∞ÏÑú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º ÎÅäÏßÄ ÏïäÏùå
        
        // Clean up page cache
        try {
            pageCache?.destroy()
            Log.d("PdfViewerActivity", "PageCache Ï†ïÎ¶¨ ÏôÑÎ£å")
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "Error destroying pageCache in onDestroy: ${e.message}")
        }
        
        try {
            currentPage?.close()
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "Error closing currentPage in onDestroy: ${e.message}")
        }
        try {
            pdfRenderer?.close()
        } catch (e: Exception) {
            Log.w("PdfViewerActivity", "Error closing pdfRenderer in onDestroy: ${e.message}")
        }
    }
}